<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>热爱至上</title>
  
  <subtitle>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-05T06:21:06.477Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Symbol</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>link和@import的区别</title>
    <link href="http://yoursite.com/2017/10/22/link%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/10/22/link和-import的区别/</id>
    <published>2017-10-22T04:15:32.000Z</published>
    <updated>2018-02-05T06:21:06.477Z</updated>
    
    <content type="html"><![CDATA[<p>页面使用css 的三种方式：行内样式，页面头部嵌入style【内联样式】，外联样式link 和@import 如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// XHL/HTML代码</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">rev</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css文件"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// XHL/HTML代码</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">"CSS文件"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>两者的区别<ul><li>1.link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务，@import属于css范畴，只能加载css</li><li>2.link引入css,再页面加载同时加载，@import需要页面全部加载完成以后才加载</li><li>3.link 是XHTML标签，无兼容问题，@import不支持低版本浏览器</li><li>4.link 支持js控制DOM修改样式，而@import 不支持</li></ul></li></ul><p>RSS（简易信息聚合，也叫聚合内容）是一种描述和同步网站内容的格式。网站提供RSS输出，有利于让用户获取网站内容的最新更新。</p><p>优先级：行内&gt;内联&gt;外联【link】&gt;导入【@import】<br>近水楼台先得月</p>]]></content>
    
    <summary type="html">
    
      link和@import的区别
    
    </summary>
    
      <category term="前端基础(理论)" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Get请求与Post请求</title>
    <link href="http://yoursite.com/2017/10/16/Get%E8%AF%B7%E6%B1%82%E4%B8%8EPost%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2017/10/16/Get请求与Post请求/</id>
    <published>2017-10-16T06:28:09.000Z</published>
    <updated>2017-10-20T12:35:03.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="get-与-post的区别"><a href="#get-与-post的区别" class="headerlink" title="get 与 post的区别"></a>get 与 post的区别</h3><blockquote><p><strong>get</strong>:<br>用get方式可传送简单数据，但大小一般限制在1KB下，数据追加到url中发送（http的header传送），会被刘浏览器客户端缓存，别人就可以在浏览器的历史纪录里读取到客户的数据，不安全。<br><strong>post</strong>:<br>当使用POST方式时，浏览器把各表单字段元素及其数据作为HTTP消息的实体内容发送给Web服务器，而不是作为URL地址的参数进行传递，使用POST方式传递的数据量要比使用GET方式传送的数据量大的多。<br>总之，GET方式传送数据量小，处理效率高，安全性低，会被缓存，而POST反之。</p></blockquote><p><strong>使用get方式需要注意：</strong><br>对于get请求（或凡涉及到url传递参数的），被传递的参数都要先经encodeURIComponent方法处理.例：var url = “update.php?username=” +encodeURIComponent(username) + “&amp;content=” +encodeURIComponent<br>(content)+”&amp;id=1” ;</p><p><strong>使用Post方式需注意：</strong><br>1.设置header的Context-Type为application/x-www-form-urlencode确保服务器知道实体中有参数变量. 通常使用XmlHttpRequest对象的SetRequestHeader(“Context-Type”,”application/x-www- form-urlencoded;”)。例：<br>xmlHttp.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”);<br>2.参数是名/值一一对应的键值对,每对值用&amp;号隔开.如 var name=abc&amp;sex=man&amp;age=18，注意var name=update.php?abc&amp;sex=man&amp;age=18以及var name=?abc&amp;sex=man&amp;age=18的写法都是错误的;<br>3.参数在Send(参数)方法中发送,例： xmlHttp.send(name); 如果是get方式，直接 xmlHttp.send(null);<br>4.服务器端请求参数区分Get与Post。如果是get方式则$username = $_GET[“username”]; 如果是post方式，则$username = $_POST[“username”];</p><h3 id="AJAX乱码问题"><a href="#AJAX乱码问题" class="headerlink" title="AJAX乱码问题"></a>AJAX乱码问题</h3><p>1、xtmlhttp 返回的数据默认的字符编码是utf-8，如果客户端页面是gb2312或者其它编码数据就会产生乱码<br>2、post方法提交数据默认的字符编码是utf-8，如果服务器端是gb2312或其他编码数据就会产生乱码</p><p><strong>解决办法有：</strong><br>1、若客户端是gb2312编码，则在服务器指定输出流编码<br>2、服务器端和客户端都使用utf-8编码<br>gb2312:header(‘Content-Type:text/html;charset=GB2312’);<br>utf8:header(‘Content-Type:text/html;charset=utf-8’);</p>]]></content>
    
    <summary type="html">
    
      get 与 post的区别及使用
    
    </summary>
    
      <category term="前端基础(理论)" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>es6之Generator</title>
    <link href="http://yoursite.com/2017/10/13/es6%E4%B9%8BGenerator/"/>
    <id>http://yoursite.com/2017/10/13/es6之Generator/</id>
    <published>2017-10-13T07:52:01.000Z</published>
    <updated>2017-10-14T11:21:10.446Z</updated>
    
    <content type="html"><![CDATA[<p>from:<a href="http://es6.ruanyifeng.com/#docs/generator#应用" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/generator#应用</a></p><h3 id="generator-基本概念"><a href="#generator-基本概念" class="headerlink" title="generator 基本概念"></a>generator 基本概念</h3><blockquote><p>和普通函数一样，但是有两个特征：<br>1.function关键字和函数名之间有个 * 符号；<br>2.函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。<br>3.遍历器生成函数。<br>注：调用方法和普通函数一样,当函数内部遇到yield 或return 时会返回指定值，函数停止执行;<br>当再次使用 obj.next()时继续从停止的位置往下执行<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上 demo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line">hw.next();   <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();   <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();   <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()    <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码一共调用了四次next方法。</span></span><br><span class="line"><span class="comment">// 第一次，遇到yield,返回一个对象,值为‘hello’,done属性false 表示遍历还没有结束【以此类推】</span></span><br></pre></td></tr></table></figure></p></blockquote><p>小结：总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h3><blockquote><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p></blockquote><p>注意：generator 函数可以不用yield 表达式，这时，generator函数就变成了一个暂缓执行函数<br>不用yield表达式 同样需要 next() 调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行了！'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generator = f();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  generator.next()</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// 两秒后输出 --&gt; 执行了！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// yield表达式如果用在另一个表达式之中，必须放在圆括号里面。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><p>yield表达式本身没有返回值，或者说总是返回undefined。<br>next方法可以带一个参数，该参数就会被当做上一个yield 表达式的返回值。<br>demo如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next()</span><br><span class="line"><span class="comment">// Object&#123;value:6, done:false&#125; 第一次调用，参数为5，返回的yield值为6</span></span><br><span class="line">a.next()</span><br><span class="line"><span class="comment">// Object&#123;value:NaN, done:false&#125; 第二次，next()没有参数，导致 y = 2 * undefined,所以返回 NAN。</span></span><br><span class="line">a.next()</span><br><span class="line"> <span class="comment">// Object&#123;value:NaN, done:true&#125; 第三次同第二次。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next()</span><br><span class="line"><span class="comment">// &#123; value:6, done:false &#125; 第一次正常返回。</span></span><br><span class="line">b.next(<span class="number">12</span>)</span><br><span class="line"><span class="comment">// &#123; value:8, done:false &#125; 第二次当next 传12参数时，导致 y = 2 * 12，z = 24/3 ,返回值为 8。</span></span><br><span class="line">b.next(<span class="number">13</span>)</span><br><span class="line"><span class="comment">// &#123; value:42, done:true &#125; 第三次，x = 5, y = 24, z = 13 ,return 42。</span></span><br></pre></td></tr></table></figure></p><p>上面的例子好像不是很明了，来个简单点的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次通过next方法向 Generator 函数输入值，然后打印出来。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dataConsumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Started'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`1. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`2. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genObj = dataConsumer();</span><br><span class="line">genObj.next();</span><br><span class="line"><span class="comment">// Started</span></span><br><span class="line">genObj.next(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// 1. a</span></span><br><span class="line">genObj.next(<span class="string">'b'</span>)</span><br><span class="line"><span class="comment">// 2. b</span></span><br></pre></td></tr></table></figure></p><h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><blockquote><p>作用自动遍历Genertor 函数时生成Iterator 对象，此时再也不需要next 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function *foo() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  yield 4;</span><br><span class="line">  yield 5;</span><br><span class="line">  return 6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let v of foo()) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">// 上面代码使用for...of循环，依次显示5个yield表达式的值。这里需要注意，</span><br><span class="line">// 一旦next方法的返回对象的done属性为true，for...of循环就会中止，</span><br><span class="line">// 且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。</span><br></pre></td></tr></table></figure></p></blockquote><p>下面是一个利用 Generator 函数和for…of循环，实现斐波那契数列的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        [prev, curr] = [curr, prev + curr];</span><br><span class="line">        <span class="keyword">yield</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="generator-prototype…"><a href="#generator-prototype…" class="headerlink" title="generator.prototype…"></a>generator.prototype…</h3><p>generator的原型上包含 next(),return(),throw()这几个方法<br>阮老师的文章里这三个方法是分开讲的，在这里我把他们放在一起，便于记忆，对比理解</p><blockquote><p>这三个方法本质上是同一件事，们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next()是将yield表达式替换成一个值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = g(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.next(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>throw()是将yield表达式替换成一个throw语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error('出错了'));</span></span><br></pre></td></tr></table></figure></p><p>return()是将yield表达式替换成一个return语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.return(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure></p><h3 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h3><blockquote><p>如果一个Generator 函数内部调用另一个Generator 函数，是没有效果的，这时，就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是没有用 yield* 表达式，默认情况下是没有效果的。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "x"</span></span><br><span class="line"><span class="comment">// "y"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是用了 yield* 表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "x"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "y"</span></span><br></pre></td></tr></table></figure></p></blockquote><p>yield*命令可以很方便地取出嵌套数组的所有成员。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterTree</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* iterTree(tree[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = [ <span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'d'</span>, <span class="string">'e'</span>] ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> iterTree(tree)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure></p><h3 id="作为对象属性的Generator-函数"><a href="#作为对象属性的Generator-函数" class="headerlink" title="作为对象属性的Generator 函数"></a>作为对象属性的Generator 函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    * myGeneratorMethod()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码等同于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Generator函数的this"><a href="#Generator函数的this" class="headerlink" title="Generator函数的this"></a>Generator函数的this</h3><blockquote><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">g.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hi!'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true</span></span><br><span class="line">obj.hello() <span class="comment">// 'hi!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。</span></span><br><span class="line"><span class="comment">//但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line">obj.a <span class="comment">// undefined</span></span><br><span class="line">上面代码中，Generator函数g在<span class="keyword">this</span>对象上面添加了一个属性a，但是obj对象拿不到这个属性。</span><br></pre></td></tr></table></figure></p></blockquote><p>Generator函数也不能跟new命令一起用，会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> F()</span><br><span class="line"><span class="comment">// TypeError: F is not a constructor</span></span><br><span class="line"><span class="comment">//new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。</span></span><br></pre></td></tr></table></figure></p><p>那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？<br>下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = F.call(obj);</span><br><span class="line"></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">obj.a <span class="comment">// 1</span></span><br><span class="line">obj.b <span class="comment">// 2</span></span><br><span class="line">obj.c <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">代码中，首先是F内部的<span class="keyword">this</span>对象绑定obj对象，然后调用它，返回一个 Iterator 对象。</span><br><span class="line">这个对象执行三次next方法（因为F内部有两个<span class="keyword">yield</span>表达式），</span><br><span class="line">完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      generator原理及使用方法
    
    </summary>
    
      <category term="Es6" scheme="http://yoursite.com/categories/Es6/"/>
    
    
      <category term="Es6" scheme="http://yoursite.com/tags/Es6/"/>
    
  </entry>
  
  <entry>
    <title>es6之Promise</title>
    <link href="http://yoursite.com/2017/10/12/es6%E4%B9%8BPromise/"/>
    <id>http://yoursite.com/2017/10/12/es6之Promise/</id>
    <published>2017-10-12T08:17:58.000Z</published>
    <updated>2017-10-14T02:09:52.205Z</updated>
    
    <content type="html"><![CDATA[<p>from: <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise</a></p><h3 id="什么是promise-对象"><a href="#什么是promise-对象" class="headerlink" title="什么是promise 对象"></a>什么是promise 对象</h3><p><img src="/2017/10/12/es6之Promise/promise.jpg" alt="“Promise.prototype”"></p><blockquote><p>Promise对象<br>  从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。<br>  Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p></blockquote><hr><blockquote><p>Promise对象有以下两个特点:<br>（1）对象的状态不受外界影响。<br>     Promise对象代表一个异步操作。<br>     有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。<br>     只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<br>     Promise对象的状态改变，只有两种可能：pending -&gt; fulfilled or pending -&gt; 和rejected。<br>     只要这两种情况发生，状态就凝固了，不会再变了，这时就称为 resolved（已定型）。<br>     如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p></blockquote><h3 id="Promise-优点和缺点"><a href="#Promise-优点和缺点" class="headerlink" title="Promise 优点和缺点"></a>Promise 优点和缺点</h3><blockquote><p><strong>优点</strong></p><ol><li>Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</li><li>此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</li></ol></blockquote><hr><p><strong>缺点</strong></p><ol><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例</strong></p><blockquote><p>下面代码中，getJSON是对 XMLHttpRequest 对象的封装，<br>用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。<br>需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。<br>他们的参数会传给 .then()方法里自己对应的两个回掉函数，then()方法是定义在 Promise原型对象上的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Promise对象实现的 Ajax 操作的例子。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);   <span class="comment">// 应该写为  return resolve(1);这样后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><blockquote><p>1.定义在Promise的原型上，它的作用是为 Promise 实例添加状态改变时的回调函数。<br>2.then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。<br>3.then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。<br>4.因此可以采用链式写法，即then方法后面再调用另一个then方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。</span></span><br><span class="line"><span class="comment">// 这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。</span></span><br><span class="line"><span class="comment">// 如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</span></span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line">-----------------------------以下是箭头函数写法-----------------------------</span><br><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><blockquote><p>简单的说，有了catch()方法后，then()方法里的 reject()对应的回调函数可以放在它里面了，<br>catch()方法专门用来捕获和处理错误信息，必须放在 then()方法之后调用，否则捕获不到错误，<br>catch()方法可以链式调用，后一个catch()用来捕获前一个catch()抛出的错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的 demo</span></span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><blockquote><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>var p = Promise.all([p1, p2, p3]);</p></blockquote><p>注意：p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，<br>将参数转为 Promise 实例，再进一步处理。<br>【Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例】</p><p>p的状态由p1、p2、p3决定，分成两种情况。<br>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p><p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo --&gt; 生成一个Promise对象的数组</span></span><br><span class="line"><span class="comment">//promises是包含6个 Promise 实例的数组，只有这6个实例的状态都变成fulfilled，</span></span><br><span class="line"><span class="comment">//或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">'/post/'</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（3）作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。<br>下面代码注释：<br>p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，<br>p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。<br>如果p2 没有定义自己的 catch();那么就会执行 Promise.all()的catch()方法；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure></p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><blockquote><p>同Promise.all()方法的作用一样，是将多个Promise实例，包装成一个新的Promise实例。<br>下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response));</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将jQuery生成的deferred对象，转为一个新的Promise对象。</span></span><br><span class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure></p><p>Promise.resolve方法的参数分成四种情况。<br>（1）参数是一个Promise实例<br>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。<br>（2）参数是一个thenable【指的是具有then方法的对象】对象，如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</span></span><br><span class="line"><span class="comment">//thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。</span></span><br><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>（3）参数不是具有then方法的对象，或根本就不是对象<br>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于字符串Hello不属于异步操作（判断方法是字符串对象不具有then方法）</span></span><br><span class="line"><span class="comment">// 返回Promise实例的状态从一生成就是resolved，所以回调函数会立即执行。</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></p><p>（4）不带有任何参数<br>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>执行顺序<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout(fn, 0)在下一轮“事件循环”开始时执行。</span></span><br><span class="line"><span class="comment">// Promise.resolve()在本轮“事件循环”结束时执行。</span></span><br><span class="line"><span class="comment">// console.log('one')则是立即执行，因此最先输出。</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例,该实例的状态为rejected。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise.reject方法的参数是一个thenable对象</span></span><br><span class="line"><span class="comment">// 执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="有用的附加方法之-done-和-finally"><a href="#有用的附加方法之-done-和-finally" class="headerlink" title="有用的附加方法之 done() 和 finally()"></a>有用的附加方法之 done() 和 finally()</h3><p>Promise对象的会掉链不管以then或catch方法结尾，要是最后一个方法抛出错误，都有可能捕获不到，<br>【因为Promise内部的错误不会冒泡到全局】,因此，可以提供一个done方法，总是处于回调链的末端，<br>保证抛出任何可能出现的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// done方法的使用，可以像then方法那样用，提供fulfilled和rejected状态的回调函数，也可以不提供任何参数。</span></span><br><span class="line"><span class="comment">// 但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">asyncFunc()</span><br><span class="line">  .then(f1)</span><br><span class="line">  .catch(r1)</span><br><span class="line">  .then(f2)</span><br><span class="line">  .done();</span><br><span class="line"></span><br><span class="line"><span class="comment">// done()方法实现代码</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 抛出一个全局错误</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>finally()<br>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。<br>它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。</span></span><br><span class="line">server.listen(<span class="number">0</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// run test</span></span><br><span class="line">      &#125;)</span><br><span class="line">    .finally(server.stop);</span><br><span class="line"></span><br><span class="line"><span class="comment">// finally() 实现代码</span></span><br><span class="line"><span class="comment">// 代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">        value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">        reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="应用【加载图片】"><a href="#应用【加载图片】" class="headerlink" title="应用【加载图片】"></a>应用【加载图片】</h3><p>可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">        image.onload  = resolve;</span><br><span class="line">        image.onerror = reject;</span><br><span class="line">        image.src = path;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用Generator 函数管理流程，遇到异步操作的时候，通常返回一个 Promise对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码的Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。</span></span><br><span class="line"><span class="comment">// 函数run用来处理这个Promise对象，并调用下一个next方法。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">'aaa'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> it = generator();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">       &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g); <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure></p><h3 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h3><p>实际开发中，经常遇到一种情况:不知道或者不想区分，函数f是同步函数还是异步函数操作，<br>但是想用Promise 来处理他。因为这样就可以不管是同步还是异步，都用then 方法指定下<br>一部流程，用catch 方法处理 f 抛出的错误，一般会采用下面的写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写有一个缺点，就是 f 是同步函数，那么它会在本轮事件末尾执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。</span></span><br></pre></td></tr></table></figure></p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；</span></span><br><span class="line"><span class="comment">// 如果f是异步的，就可以用then指定下一步，就像下面的写法。</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br><span class="line"><span class="comment">//需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure></p><p>第二种写法是使用new Promise()。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">  () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。</span></span><br></pre></td></tr></table></figure></p><p>鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。<br>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。<br>这样有许多好处，其中一点就是可以更好地管理异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsername</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中，database.users.get()返回一个 Promise 对象</span></span><br><span class="line"><span class="comment">// 如果抛出异步错误，可以用catch方法捕获，就像下面这样写。</span></span><br><span class="line">database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法）</span></span><br><span class="line"><span class="comment">//这时你就不得不用try...catch去捕获。</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">    .then(...)</span><br><span class="line">    .catch(...)</span><br><span class="line">&#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。</span></span><br><span class="line"><span class="built_in">Promise</span>.try(database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">    .then(...)</span><br><span class="line">    .catch(...)</span><br></pre></td></tr></table></figure><p>其实，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p>]]></content>
    
    <summary type="html">
    
      promise原理及使用方法
    
    </summary>
    
      <category term="Es6" scheme="http://yoursite.com/categories/Es6/"/>
    
    
      <category term="Es6" scheme="http://yoursite.com/tags/Es6/"/>
    
  </entry>
  
  <entry>
    <title>常见跨域解决方案</title>
    <link href="http://yoursite.com/2017/10/11/%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/10/11/常见跨域解决方案/</id>
    <published>2017-10-11T08:24:20.000Z</published>
    <updated>2017-10-14T02:09:52.220Z</updated>
    
    <content type="html"><![CDATA[<p>from: <a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011145364</a></p><h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一. 广义上，跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。</span><br><span class="line">  1.) 资源跳转： A链接、重定向、表单提交</span><br><span class="line">  2.) 资源嵌入：<span class="tag">&lt;<span class="name">link</span>&gt;</span>、<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml">、<span class="tag">&lt;<span class="name">img</span>&gt;</span>、<span class="tag">&lt;<span class="name">frame</span>&gt;</span>等dom标签，还有样式中background:url()、@font-face()等文件外链</span></span><br><span class="line"><span class="undefined">  3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">二.其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</span></span><br><span class="line"><span class="undefined">  所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</span></span><br><span class="line"><span class="undefined">  同源策略限制以下几种行为：</span></span><br><span class="line"><span class="undefined">  1.) Cookie、LocalStorage 和 IndexDB 无法读取</span></span><br><span class="line"><span class="undefined">  2.) DOM 和 Js对象无法获得</span></span><br><span class="line"><span class="undefined">  3.) AJAX 请求不能发送</span></span><br></pre></td></tr></table></figure><h3 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">URL                                说明                           是否允许通信</span><br><span class="line">http:<span class="comment">//www.domain.com/a.js</span></span><br><span class="line">http:<span class="comment">//www.domain.com/b.js         同一域名，不同文件或路径          允许</span></span><br><span class="line">http:<span class="comment">//www.domain.com/lab/c.js</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.domain.com:8000/a.js</span></span><br><span class="line">http:<span class="comment">//www.domain.com/b.js         同一域名，不同端口                不允许</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.domain.com/a.js</span></span><br><span class="line">https:<span class="comment">//www.domain.com/b.js        同一域名，不同协议                不允许</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.domain.com/a.js</span></span><br><span class="line">http:<span class="comment">//192.168.4.12/b.js           域名和域名对应相同ip              不允许</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.domain.com/a.js</span></span><br><span class="line">http:<span class="comment">//x.domain.com/b.js           主域相同，子域不同                不允许</span></span><br><span class="line">http:<span class="comment">//domain.com/c.js</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.domain1.com/a.js</span></span><br><span class="line">http:<span class="comment">//www.domain2.com/b.js        不同域名                          不允许</span></span><br></pre></td></tr></table></figure><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><h4 id="1-通过jsonp跨域【jsonp缺点：只能实现get一种请求。】"><a href="#1-通过jsonp跨域【jsonp缺点：只能实现get一种请求。】" class="headerlink" title="1.通过jsonp跨域【jsonp缺点：只能实现get一种请求。】"></a>1.通过jsonp跨域【jsonp缺点：只能实现get一种请求。】</h4><pre><code>如果从另一台服务器请求资源想得到浏览器的允许，那么，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>）原生实现：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传参并指定回调执行函数为onBack</span></span><br><span class="line">    script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调执行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">服务端返回如下（返回时即执行全局函数）：</span></span><br><span class="line"><span class="regexp">onBack(&#123;"status": true, "user": "admin"&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">2.）jquery ajax：</span></span><br><span class="line"><span class="regexp">$.ajax(&#123;</span></span><br><span class="line"><span class="regexp">    url: 'http:/</span><span class="regexp">/www.domain2.com:8080/</span>login<span class="string">',</span></span><br><span class="line"><span class="string">    type: '</span>get<span class="string">',</span></span><br><span class="line"><span class="string">    dataType: '</span>jsonp<span class="string">',  // 请求方式为jsonp</span></span><br><span class="line"><span class="string">    jsonpCallback: "onBack",    // 自定义回调函数名</span></span><br><span class="line"><span class="string">    data: &#123;&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3.）vue.js：</span></span><br><span class="line"><span class="string">this.$http.jsonp('</span>http:<span class="comment">//www.domain2.com:8080/login', &#123;</span></span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: <span class="string">'onBack'</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">后端node.js代码示例：</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span> &#125;);</span><br><span class="line">    res.write(fn + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><h4 id="2、-document-domain-iframe跨域【此方案仅限主域相同，子域不同的跨域应用场景。】"><a href="#2、-document-domain-iframe跨域【此方案仅限主域相同，子域不同的跨域应用场景。】" class="headerlink" title="2、 document.domain + iframe跨域【此方案仅限主域相同，子域不同的跨域应用场景。】"></a>2、 document.domain + iframe跨域【此方案仅限主域相同，子域不同的跨域应用场景。】</h4><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>）父窗口：(http:<span class="comment">//www.domain.com/a.html)</span></span><br><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://child.domain.com/b.html"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="string">'admin'</span>;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">2.）子窗口：(http:/</span><span class="regexp">/child.domain.com/</span>b.html)</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span><br><span class="line">    <span class="comment">// 获取父窗口中变量</span></span><br><span class="line">    alert(<span class="string">'get js data from parent ---&gt; '</span> + <span class="built_in">window</span>.parent.user);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="3、-location-hash-iframe"><a href="#3、-location-hash-iframe" class="headerlink" title="3、 location.hash + iframe"></a>3、 location.hash + iframe</h4><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。<br>三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>）a.html：(http:<span class="comment">//www.domain1.com/a.html)</span></span><br><span class="line"></span><br><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain2.com/b.html"</span> style=<span class="string">"display:none;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe&amp;gt</span></span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById('iframe');</span><br><span class="line"></span><br><span class="line">    // 向b.html传hash值</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        iframe.src = iframe.src + '#user=admin';</span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">    // 开放给同域c.html的回调方法</span><br><span class="line">    function onCallback(res) &#123;</span><br><span class="line">        alert('data from c.html ---&gt; ' + res);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">2.）b.html：(http://www.domain2.com/b.html)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.domain1.com/c.html"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById('iframe');</span><br><span class="line"></span><br><span class="line">    // 监听a.html传来的hash值，再传给c.html</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">3.）c.html：(http://www.domain1.com/c.html)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 监听b.html传来的hash值</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        // 再通过操作同域a.html的js回调，将结果传回</span><br><span class="line">        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h4 id="4、-window-name-iframe跨域"><a href="#4、-window-name-iframe跨域" class="headerlink" title="4、 window.name + iframe跨域"></a>4、 window.name + iframe跨域</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，<br>并且可以支持非常长的 name 值（2MB）。</p><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。<br>这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>）a.html：(http:<span class="comment">//www.domain1.com/a.html)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载跨域页面</span></span><br><span class="line">    iframe.src = url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span></span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">            iframe.contentWindow.location = <span class="string">'http://www.domain1.com/proxy.html'</span>;</span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destoryFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        iframe.contentWindow.document.write(<span class="string">''</span>);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求跨域b页面数据</span></span><br><span class="line">proxy(<span class="string">'http://www.domain2.com/b.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>）proxy.html：(http:<span class="comment">//www.domain1.com/proxy….</span></span><br><span class="line">中间代理页，与a.html同域，内容为空即可。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>）b.html：(http:<span class="comment">//www.domain2.com/b.html)</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.name = <span class="string">'This is domain2 data!'</span>;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="5、-postMessage跨域"><a href="#5、-postMessage跨域" class="headerlink" title="5、 postMessage跨域"></a>5、 postMessage跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，<br>    它可用于解决以下方面的问题：<br>    a.） 页面和其打开的新窗口的数据传递<br>    b.） 多窗口之间消息传递<br>    c.） 页面与嵌套的iframe消息传递<br>    d.） 上面三个场景的跨域数据传递</p><p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串<br>，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，<br>如果要指定和当前窗口同源的话设置为”/”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>）a.html：(http:<span class="comment">//www.domain1.com/a.html)</span></span><br><span class="line"></span><br><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain2.com/b.html"</span> style=<span class="string">"display:none;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = &#123;</span><br><span class="line">            name: <span class="string">'aym'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 向domain2传送跨域数据</span></span><br><span class="line">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain2.com'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受domain2返回数据</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'data from domain2 ---&gt; '</span> + e.data);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">2.）b.html：(http:/</span><span class="regexp">/www.domain2.com/</span>b.html)</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 接收domain1的数据</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'data from domain1 ---&gt; '</span> + e.data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            data.number = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理后再发回domain1</span></span><br><span class="line">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain1.com'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>6、 WebSocket协议跨域<br>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，<br>同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，<br>提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>）前端代码：</span><br><span class="line"></span><br><span class="line">&lt;div&gt;user input：&lt;input type=<span class="string">"text"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"./socket.io.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> socket = io(<span class="string">'http://www.domain2.com:8080'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功处理</span></span><br><span class="line">socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听服务端消息</span></span><br><span class="line">    socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data from server: ---&gt; '</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务端关闭</span></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Server socket has closed.'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">2.）Nodejs socket后台：</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var http = require('http');</span></span><br><span class="line"><span class="regexp">var socket = require('socket.io');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 启http服务</span></span><br><span class="line"><span class="regexp">var server = http.createServer(function(req, res) &#123;</span></span><br><span class="line"><span class="regexp">    res.writeHead(200, &#123;</span></span><br><span class="line"><span class="regexp">        'Content-type': 'text/</span>html<span class="string">'</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    res.end();</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">server.listen('</span><span class="number">8080</span><span class="string">');</span></span><br><span class="line"><span class="string">console.log('</span>Server is running at port <span class="number">8080.</span>..<span class="string">');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 监听socket连接</span></span><br><span class="line"><span class="string">socket.listen(server).on('</span>connection<span class="string">', function(client) &#123;</span></span><br><span class="line"><span class="string">    // 接收信息</span></span><br><span class="line"><span class="string">    client.on('</span>message<span class="string">', function(msg) &#123;</span></span><br><span class="line"><span class="string">        client.send('</span>hello：<span class="string">' + msg);</span></span><br><span class="line"><span class="string">        console.log('</span>data <span class="keyword">from</span> client: ---&gt; <span class="string">' + msg);</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 断开处理</span></span><br><span class="line"><span class="string">    client.on('</span>disconnect<span class="string">', function() &#123;</span></span><br><span class="line"><span class="string">        console.log('</span>Client socket has closed.<span class="string">');</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      常见跨域问题的解决
    
    </summary>
    
      <category term="实用技术" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="实用技术" scheme="http://yoursite.com/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>图像性能清单</title>
    <link href="http://yoursite.com/2017/10/11/%E5%9B%BE%E5%83%8F%E6%80%A7%E8%83%BD%E6%B8%85%E5%8D%95/"/>
    <id>http://yoursite.com/2017/10/11/图像性能清单/</id>
    <published>2017-10-11T02:21:07.000Z</published>
    <updated>2017-10-14T02:09:52.220Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://caniuse.com" target="_blank" rel="noopener">http://caniuse.com</a>  //属性兼容度</p><ul><li>优化清单<ul><li>选择正确的图片格式</li><li>尽可能使用矢量图形</li><li>如果变化不明显，则降低图片质量</li><li>使用新格式图片</li><li>使用工具与算法优化</li><li>使用srcset和picture</li><li>使用图片 CDN</li></ul></li></ul><h3 id="srcset属性"><a href="#srcset属性" class="headerlink" title="srcset属性"></a>srcset属性</h3><p>使用下面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image-128.png"</span> <span class="attr">srcset</span>=<span class="string">"image-256.png 2x"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">新标准</span><br><span class="line">目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片的话，太麻烦了。所以就有了新的srcset标准。</span><br><span class="line">其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。</span><br><span class="line">对于srcset里面出现了一个w单位，可以理解成图片质量。</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"image-128.png"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">srcset</span>=<span class="string">"image-128.png 128w, image-256.png 256w, image-512.png 512w"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">sizes</span>=<span class="string">"(max-width: 360px) 340px, 128px"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">如果可视区域小于这个质量的值，就可以使用，当然，浏览器会自动选择一个最小的可用图片。</span><br><span class="line">上面例子中的sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">img的srcset属性方便的解决了页面图片适应不同屏幕密度的情况。目前除了IE没有兼容到，已经全部都兼容了。</span><br></pre></td></tr></table></figure></p><h3 id="picture-标签"><a href="#picture-标签" class="headerlink" title="picture 标签"></a>picture 标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span>标签的存在其目的是为了能用更灵活的和熟悉的语法，去解决一些问题例。</span><br><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span>标签在source元素中可以使用media属性，和video标签类似。这使我们能够针对图像源做一些组合：</span><br><span class="line">viewport的高度和宽度，以像素或ems为单位，使用min或max值，就和我们使用CSS　media查询一样。</span><br><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"med.jpg"</span> <span class="attr">media</span>=<span class="string">"(min-width: 40em)"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"sm.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"fallback.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br><span class="line"></span><br><span class="line">要注意的是，是可以在<span class="tag">&lt;<span class="name">picture</span>&gt;</span>标签中使用srcset属性的，例子如下：</span><br><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"med.jpg 1x, med-hd.jpg 2x"</span> <span class="attr">media</span>=<span class="string">"(min-width: 40em)"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"sm.jpg 1x, sm-hd.jpg 2x"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"fallback.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>什么是：<br>cdn缓存就是在浏览器和服务器之间增加的一层缓存，缓存一些html,img,css,xml等静态资源。</p><p>作用：<br>客户端浏览器先检查是否有本地缓存是否过期，如果过期，<br>则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，<br>如果没有过期，则直接响应用户请求，此时一个完成http请求结束;<br>如果数据已经过期，那么CDN还需要向源站发出回源请求(back to the source request),来拉取最新的数据。</p><p>CDN加速原理：<br>用户的请求被分配到离自己最快的服务器  –&gt; 网络加速+内容缓存，有效提供访问速度;</p><p>CDN缓存什么内容:<br>缓存html、图片、css、xml等静态资源，不缓存含有？的动态地址、jsp、php，js文件也不缓存【除非特殊设置】<br>缓存原站返回HTTP状态为20*或304，不缓存其他状态(例如404，500，503)</p>]]></content>
    
    <summary type="html">
    
      关于图片的优化
    
    </summary>
    
      <category term="img" scheme="http://yoursite.com/categories/img/"/>
    
    
      <category term="实用技术" scheme="http://yoursite.com/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>es6简介</title>
    <link href="http://yoursite.com/2017/10/09/es6%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/10/09/es6简介/</id>
    <published>2017-10-09T05:30:42.000Z</published>
    <updated>2017-10-14T02:09:52.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><ul><li>基本用法<ul><li>只在let命令所在的代码块内有效</li><li>不存在变量提升</li><li>暂时性死区【只要块级作用域内存在let命令，它的生命变量就绑定这个区域，不再受外部影响】</li><li>let命令模块内部不允许重复声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--------------只在<span class="keyword">let</span>命令所在的代码块内有效demo------------</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// b is not defined  -- Error</span></span><br><span class="line">--------------不存在变量提升demo------------</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> c = i;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">5</span>](); <span class="comment">// var声明结果 9</span></span><br><span class="line">a[<span class="number">5</span>](); <span class="comment">// let声明结果 5</span></span><br><span class="line">---------------暂时性死区demo----------------</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">200</span>;    <span class="comment">// 内部输出不会受外部影响</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">100</span>;    <span class="comment">// let声明之前的区域属于暂时性死区，必须放在作用域顶部声明</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num =<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun();<span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><ul><li>作用<ul><li>声明常量</li><li>一旦声明不可改变</li></ul></li></ul><h3 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> num1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> num2 = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> num3 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use.js   【如果需要引入所有常量】</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> message form <span class="string">'./module'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.num1);</span><br><span class="line"><span class="built_in">console</span>.log(message.num2);</span><br><span class="line"><span class="built_in">console</span>.log(message.num3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// otherUser.js 【如果只用部分】</span></span><br><span class="line"><span class="keyword">import</span> &#123;num1，num2&#125; <span class="keyword">as</span> message form <span class="string">'./module'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.num1);</span><br><span class="line"><span class="built_in">console</span>.log(message.num2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      let 和 const命令
    
    </summary>
    
      <category term="Es6" scheme="http://yoursite.com/categories/Es6/"/>
    
    
      <category term="Es6" scheme="http://yoursite.com/tags/Es6/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://yoursite.com/2017/09/30/Flex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2017/09/30/Flex布局/</id>
    <published>2017-09-30T06:29:33.000Z</published>
    <updated>2018-02-05T06:23:50.623Z</updated>
    
    <content type="html"><![CDATA[<p>结合阮一峰老师的 Flex 布局教程，对flex相关知识做以下整理，加深对flex的理解和认识,方便以后运用<br>参考自：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a><br>实战篇：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a><br>效果参考：<a href="http://static.vgee.cn/static/index.html" target="_blank" rel="noopener">http://static.vgee.cn/static/index.html</a></p><h3 id="标准模型-怪异模型区别"><a href="#标准模型-怪异模型区别" class="headerlink" title="标准模型/怪异模型区别"></a>标准模型/怪异模型区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">标准模型：一个元素总宽度 = width + margin(左右) + padding(左右) + border(左右);</span><br><span class="line">怪异模型：一个元素总宽度 = width + margin(左右)【即width已经包含了padding和border值】</span><br><span class="line"></span><br><span class="line">怪异模式主要表现在IE内核的浏览器。</span><br><span class="line">解决：</span><br><span class="line">    <span class="number">1.</span> 当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；</span><br><span class="line">    <span class="number">2.</span> 当设置为box-sizing:border-box时，将采用怪异模式解析计算</span><br><span class="line">    下图为例;</span><br></pre></td></tr></table></figure><p><img src="/2017/09/30/Flex布局/1.jpg" alt="&#39;border-box时&#39;"></p><h3 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flex 布局是什么?</span><br><span class="line">    Flex 是 Flexible Box 的缩写，意为<span class="string">"弹性布局"</span>，用来为盒状模型提供最大的灵活性。</span><br><span class="line">    任何一个容器都可以指定为 Flex 布局,Webkit 内核的浏览器，必须加上-webkit前缀。</span><br><span class="line">    .box&#123;</span><br><span class="line">      display: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">      display: flex;</span><br><span class="line">    &#125;</span><br><span class="line">作用:</span><br><span class="line">    <span class="number">1.</span> 采用 Flex 布局的元素，它的所有子元素自动成为容器成员。</span><br><span class="line">    <span class="number">2.</span> 容器设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</span><br></pre></td></tr></table></figure><h3 id="父容器属性"><a href="#父容器属性" class="headerlink" title="父容器属性"></a>父容器属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Flex容器的属性【<span class="number">6</span>个】：</span><br><span class="line">    <span class="comment">//  作用于 6中布局的方式【比如排列的顺序，对齐的方式...】</span></span><br><span class="line">    + flex-direction : row | row-reverse | column | column-reverse;</span><br><span class="line">        <span class="comment">//  flex-direction属性决定主轴的方向（即项目的排列方向）。</span></span><br><span class="line">        row(默认值): 从左往右,横向</span><br><span class="line">        row-reverse: 横向翻转</span><br><span class="line">        column : 纵向排列，从上往下，起始在上</span><br><span class="line">        colume : 纵向反转</span><br><span class="line"></span><br><span class="line">    + flex-wrap : nowrap | wrap | wrap-reverse;</span><br><span class="line">        <span class="comment">//  flex-wrap属性定义，如果一条轴线排不下，如何换行。</span></span><br><span class="line">        nowrap【默认】：不换行。</span><br><span class="line">        wrap：换行，第一行在上方。</span><br><span class="line">        wrap-reverse：换行，第一行在下方。</span><br><span class="line"></span><br><span class="line">    + flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">        //  flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</span><br><span class="line"></span><br><span class="line">    + justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">        //  justify-content属性定义了项目在主轴上的对齐方式。</span><br><span class="line">        flex-start（默认值）：左对齐</span><br><span class="line">        flex-end：右对齐</span><br><span class="line">        center： 居中</span><br><span class="line">        space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">        space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br><span class="line"></span><br><span class="line">    + align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">        //  align-items属性定义项目在交叉轴上如何对齐。</span><br><span class="line">        flex-start：交叉轴的起点对齐。</span><br><span class="line">        flex-end：交叉轴的终点对齐。</span><br><span class="line">        center：交叉轴的中点对齐。</span><br><span class="line">        baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">        stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br><span class="line"></span><br><span class="line">    + align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">        //  align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span><br><span class="line">        flex-start：与交叉轴的起点对齐。</span><br><span class="line">        flex-end：与交叉轴的终点对齐。</span><br><span class="line">        center：与交叉轴的中点对齐。</span><br><span class="line">        space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line">        space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line">        stretch（默认值）：轴线占满整个交叉轴。</span><br></pre></td></tr></table></figure><h3 id="成员的属性"><a href="#成员的属性" class="headerlink" title="成员的属性"></a>成员的属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">以下<span class="number">6</span>个属性设置在成员上：</span><br><span class="line">    + order: <span class="xml"><span class="tag">&lt;<span class="name">integer</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">        //  order属性定义成员的排列顺序。数值越小，排列越靠前，默认为0。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">    + flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">        //  flex-grow属性定义成员的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br><span class="line">        //  如果所有成员的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。</span><br><span class="line">        //  如果一个成员的flex-grow属性为2，其他成员都为1，则前者占据的剩余空间将比其他成员一倍。</span><br><span class="line"></span><br><span class="line">    + flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">        //  flex-shrink属性定义了成员的缩小比例，默认为1，即如果空间不足，该成员将缩小。</span><br><span class="line">        //  如果所有成员的flex-shrink属性都为1，当空间不足时，都将等比例缩小。</span><br><span class="line">        //  如果一个成员的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</span><br><span class="line">        //  负值属性无效。</span><br><span class="line"></span><br><span class="line">    + flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line">        //  flex-basis属性定义了在分配多余空间之前，成员占据的主轴空间（main size）。</span><br><span class="line">        //  浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即成员的本来大小。</span><br><span class="line">        //  它可以设为跟width或height属性一样的值（比如350px），则成员将占据固定空间。</span><br><span class="line"></span><br><span class="line">    + flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</span><br><span class="line">        //  flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</span><br><span class="line">        //  该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</span><br><span class="line">        //  *** 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</span><br><span class="line"></span><br><span class="line">    + align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">        //  align-self属性允许单个成员有与其他成员不一样的对齐方式，可覆盖align-items属性。</span><br><span class="line">        //  默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br><span class="line">        //  该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Flex布局
    
    </summary>
    
      <category term="Flex" scheme="http://yoursite.com/categories/Flex/"/>
    
    
      <category term="Flex" scheme="http://yoursite.com/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>js属性的特性</title>
    <link href="http://yoursite.com/2017/09/28/js%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/09/28/js属性的特性/</id>
    <published>2017-09-28T09:38:53.000Z</published>
    <updated>2017-10-14T02:09:52.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="属性的四大特性"><a href="#属性的四大特性" class="headerlink" title="属性的四大特性"></a>属性的四大特性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LiLei = &#123;</span><br><span class="line">    id:<span class="number">1</span>,</span><br><span class="line">    name:<span class="string">'lilei'</span>,</span><br><span class="line">    age:<span class="number">13</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getOwnPropertyDescriptor(LiLei,<span class="string">'id'</span>) );</span><br><span class="line"></span><br><span class="line">如何获取属性的四大特性：</span><br><span class="line"><span class="keyword">var</span> attr = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'属性名'</span>)</span><br><span class="line"></span><br><span class="line">四大特性:&#123;  <span class="comment">// 对属性提供基本的保护</span></span><br><span class="line">    value:实际储存属性的值,</span><br><span class="line">    writable:<span class="literal">true</span>,     <span class="comment">//控制属性是否可修改</span></span><br><span class="line">    enumerable:<span class="literal">true</span>,    <span class="comment">//控制能否在for in 时遍历到，即使为false,也能用.访问到</span></span><br><span class="line">    configurable:<span class="literal">true</span>  <span class="comment">//控制能否删除,控制是否修改以上两个特性，value特性依然能改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------demo----------------------------------</span><br><span class="line">删除name 属性</span><br><span class="line"><span class="keyword">delete</span> LiLei.name;</span><br><span class="line">禁止删除name 属性</span><br><span class="line"><span class="built_in">Object</span>.definePrototype(LiLei,<span class="string">'name'</span>&#123;</span><br><span class="line">    configurable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js 中属性的特性
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js中的class</title>
    <link href="http://yoursite.com/2017/09/28/js%E4%B8%AD%E7%9A%84class/"/>
    <id>http://yoursite.com/2017/09/28/js中的class/</id>
    <published>2017-09-28T03:42:51.000Z</published>
    <updated>2017-10-14T02:09:52.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-class"><a href="#什么是-class" class="headerlink" title="什么是 class"></a>什么是 class</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js每一个对象都有一个 class 属性，记录了对象创建时的类型，但这个属性是隐藏的，不可访问的。</span><br><span class="line">一旦创建，不会更改。</span><br></pre></td></tr></table></figure><h3 id="判断一个对象的class-类型-方法一"><a href="#判断一个对象的class-类型-方法一" class="headerlink" title="判断一个对象的class(类型)方法一"></a>判断一个对象的class(类型)方法一</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj1 =[], obj2 =&#123;&#125;, obj3=/\d&#123;6&#125;/, obj4=function()&#123;&#125;;</span><br><span class="line">//    typeof 只对于原始类型的值有作用，对于引用类型的对象无能为力</span><br><span class="line">console.log(</span><br><span class="line">   typeof(obj1),    //object</span><br><span class="line">   typeof(obj2),    //object</span><br><span class="line">   typeof(obj3),    //object</span><br><span class="line">   typeof(obj4)     //function</span><br><span class="line">);</span><br><span class="line">// 1.根据原型对象判断(亲子鉴定)</span><br><span class="line">//相当于 var bool = father.isPrototypeOf(child);</span><br><span class="line">console.log(</span><br><span class="line">   Array.prototype.isPrototypeOf(obj1), //  true</span><br><span class="line">   Array.prototype.isPrototypeOf(obj2), //  false</span><br><span class="line">   Array.prototype.isPrototypeOf(obj3), //  false</span><br><span class="line">   Array.prototype.isPrototypeOf(obj4)  //  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="判断一个对象的class-类型-方法二"><a href="#判断一个对象的class-类型-方法二" class="headerlink" title="判断一个对象的class(类型)方法二"></a>判断一个对象的class(类型)方法二</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj1 =[], obj2 =&#123;&#125;, obj3=/\d&#123;6&#125;/, obj4=function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // 根据构造函数判断(母自鉴定)</span><br><span class="line">  // 相当于 var bool = child instanceof Array</span><br><span class="line">  console.log(</span><br><span class="line">     obj1 instanceof Array, //  true</span><br><span class="line">     obj2 instanceof Array, //  false</span><br><span class="line">     obj3 instanceof Array, //  false</span><br><span class="line">     obj4 instanceof Array  //  false</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="判断一个对象的class-类型-方法三"><a href="#判断一个对象的class-类型-方法三" class="headerlink" title="判断一个对象的class(类型)方法三"></a>判断一个对象的class(类型)方法三</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var obj1 =[], obj2 =&#123;&#125;, obj3=/\d&#123;6&#125;/, obj4=function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//可以通过 obj.toString()输出 -&gt; "[object class]"</span><br><span class="line">// 其中class 可能为 Array,Object,Date...</span><br><span class="line">console.log(</span><br><span class="line">  obj1.toString == "[object Array]",  //false</span><br><span class="line">  obj2.toString == "[object Array]",  //false</span><br><span class="line">  obj3.toString == "[object Array]",  //false</span><br><span class="line">  obj4.toString == "[object Array]"   //false</span><br><span class="line">);</span><br><span class="line">这种方法的问题：obj1 为什么返回 true :</span><br><span class="line">多数内置对象重写了 toString 方法，重写的toString 方法已经无法返回class</span><br><span class="line"></span><br><span class="line">由js 多态中的[重写]造成，根据 对象类型的不同，调用的 toString 方法不一样,所以造成 obj1 返回false</span><br><span class="line">重写：</span><br><span class="line">      子对象觉得父对象的成员不好用，可在本地定义同名自由属性，覆盖父对象成员，</span><br><span class="line">      使用时，优先使用子对象的成员</span><br><span class="line">为什么要重写：</span><br><span class="line">      为了体现子对象和父对象的差异。</span><br><span class="line">解决办法：</span><br><span class="line">      这种方法最精确，也是最严格的</span><br><span class="line">      临时借用指定的函数：</span><br><span class="line">      函数.call(对象)   -&gt; 执行的瞬间相当于   对象.函数名(如： obj.toString() )</span><br><span class="line">      其实是避开了父对象原型上的toString() 方法，调用了（爷爷）的原始的 toString()</span><br><span class="line">      Object.prototype.toString.call(obj) --&gt; obj.toString();</span><br><span class="line">      console.log(</span><br><span class="line">          Object.prototype.toString.call(obj1) == "[object Array]",  //true</span><br><span class="line">          Object.prototype.toString.call(obj2) == "[object Array]",  //false</span><br><span class="line">          Object.prototype.toString.call(obj3) == "[object Array]",  //false</span><br><span class="line">          Object.prototype.toString.call(obj4) == "[object Array]"   //false</span><br><span class="line">      );</span><br></pre></td></tr></table></figure><h3 id="判断一个对象的class-类型-方法四"><a href="#判断一个对象的class-类型-方法四" class="headerlink" title="判断一个对象的class(类型)方法四"></a>判断一个对象的class(类型)方法四</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ES5: Array.isArray(obj);</span><br><span class="line">//  这个API 的原理就是第三种方法，是严格的判断</span><br><span class="line">var obj1 =[], obj2 =&#123;&#125;, obj3=/\d&#123;6&#125;/, obj4=function()&#123;&#125;;</span><br><span class="line">console.log(</span><br><span class="line">    Array.isArray(obj1),    //true</span><br><span class="line">    Array.isArray(obj2),    //false</span><br><span class="line">    Array.isArray(obj3),    //false</span><br><span class="line">    Array.isArray(obj4)     //false</span><br><span class="line">);</span><br><span class="line">--------------------- IE8 兼容问题 ---------------------</span><br><span class="line">var obj1 =[], obj2 =&#123;&#125;, obj3=/\d&#123;6&#125;/, obj4=function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">if(Array.isArray === undefined)&#123;</span><br><span class="line">    Array.isArray = function( obj ) &#123;</span><br><span class="line">        //让obj 借用Object 的原形的 toString方法;</span><br><span class="line">        //如果借用的结果等于 "[object Array]";</span><br><span class="line">        return  Object.prototype.toString.call(obj) == "[object Array]";</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(</span><br><span class="line">    Array.isArray(obj1),    //true</span><br><span class="line">    Array.isArray(obj2),    //false</span><br><span class="line">    Array.isArray(obj3),    //false</span><br><span class="line">    Array.isArray(obj4)     //false</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">注：原型中的方法 VS 构造函数的方法</span><br><span class="line">    如果规定一个方法只能被某一类的对象调用，就放在该类型的原型对象中</span><br><span class="line">    如果一个方法不确定以后使用它的对象类型，那么就要放在构造函数上，将对象作为参数</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">问题：前两个检查不仅检查直接父对象，而且还检查整个原型链。</span><br><span class="line">第三中方法完美解决前两种，与原型链无关。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js 中的类
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://yoursite.com/2017/09/27/%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/09/27/闭包/</id>
    <published>2017-09-27T03:22:15.000Z</published>
    <updated>2017-10-14T02:09:52.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">什么是：</span><br><span class="line">    即重用变量，又保护变量不被污染的一种机制</span><br><span class="line">为什么用：</span><br><span class="line">    全局变量：优：可反复使用。                   缺：易被污染   ---尽量不使用全局变量。</span><br><span class="line">    局部变量：优：不会被污染，仅函数内可用。      缺：无法反复使用</span><br><span class="line">何时使用闭包：</span><br><span class="line">    只要重用一个变量，又不希望变量被污染时</span><br><span class="line">如何使用闭包：三特点：</span><br><span class="line">    1.用外层函数包裹受保护的变量和操作变量的内层函数</span><br><span class="line">    2.外层函数，返回内层函数对象</span><br><span class="line">    3.调用者，调用外层函数，获得内层函数对象</span><br><span class="line">------------------------------ demo ------------------------------------</span><br><span class="line">//Step1: 外层函数包裹受保护的变量和操作变量的内层函数</span><br><span class="line">function outer()&#123;</span><br><span class="line">    var a=1;</span><br><span class="line">    //Step2:外层函数返回内层函数的对象</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(a++);//2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Step3:使用者调用外层函数获得内层函数的对象</span><br><span class="line">var next = outer();</span><br><span class="line">//按理说：outer调用后， a 应该被释放，为什么还能重用 ??</span><br><span class="line">// var next = outer(); 第三步，对outer 的返回值进行了赋值(把内层函数的地址给了next)，形成了引用，造成了闭包</span><br><span class="line">// next得到的是：function()&#123; console.log(a++); &#125;</span><br><span class="line">next();//1</span><br><span class="line">next();//2</span><br><span class="line">var a = 0;</span><br><span class="line">next();//3</span><br><span class="line">next();//4</span><br><span class="line">注意,调用完以后：next = null;    //释放闭包，解决内存泄漏</span><br><span class="line">------------------------------- 特殊 --------------------------------</span><br><span class="line">如果闭包只希望创建一次，反复使用，外层函数就要使用匿名函数自调</span><br><span class="line">var fun = (function()&#123;</span><br><span class="line">    var 变量;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        操作变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">//调用完，内存只剩内层小函数 fun -&gt; function()&#123; ...变量... &#125;，节约了内存</span><br></pre></td></tr></table></figure><h3 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.比普通函数占用内存(外层函数 AO 始终不释放)</span><br><span class="line">2.容易造成内存泄漏 (window 和 AO 和 内层函数 互相引用，无法释放)</span><br><span class="line"></span><br><span class="line">如何解决内存泄漏(释放闭包):</span><br><span class="line">设置引用内层函数的变量为 null;导致内层函数对象释放，导致外层函数的AO 释放，闭包就释放了</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      闭包的原理及使用
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Function Error</title>
    <link href="http://yoursite.com/2017/09/27/Error/"/>
    <id>http://yoursite.com/2017/09/27/Error/</id>
    <published>2017-09-27T02:14:29.000Z</published>
    <updated>2017-10-14T02:09:52.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="6-种错误类型"><a href="#6-种错误类型" class="headerlink" title="6 种错误类型"></a>6 种错误类型</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. SyntaxError     ---语法错误</span><br><span class="line">2. ReferenceError  ---引用错误，要用的东西没找到</span><br><span class="line">3. RangeError      ---范围错误，专指参数超范围</span><br><span class="line">4. TypeError       ---类型错误，错误的调用了对象的方法</span><br><span class="line">//    以下两种不常见</span><br><span class="line">5. EvalError</span><br><span class="line">6. URIError</span><br><span class="line">---------自定义 Error-------</span><br><span class="line">throw new Error('错误信息');</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js基础
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>nodeJs</title>
    <link href="http://yoursite.com/2017/09/26/nodeJs/"/>
    <id>http://yoursite.com/2017/09/26/nodeJs/</id>
    <published>2017-09-26T13:03:24.000Z</published>
    <updated>2017-09-26T13:55:38.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node.js是一个基于V8引擎的js运行时环境。——解释器</span><br><span class="line">时一门服务端语言，基于ECMAScript,提供了很多（前端js语言中没有的）扩展对象。——服务端语言</span><br><span class="line">Node.js可以编写独立的web服务器，无需借助其他任何的web服务器。</span><br><span class="line">Node 和 V8的区别：</span><br><span class="line">前端javaScript中：</span><br><span class="line">(1) ES原生对象：String,Date,Number,Array,Boolean,Error,Function,Object...</span><br><span class="line">(2) Bom 和 Dom 对象：window,document...</span><br><span class="line">(3) 自定义对象</span><br><span class="line">Node.js中没有Bom 和 Dom 对象</span><br><span class="line">Node.js的意义：</span><br><span class="line">(1) 执行效率比 PHP /JSP /ASPX 都要高</span><br><span class="line">(2) 使用一种语言统一了前后端开发</span><br></pre></td></tr></table></figure><h3 id="Node-js特点"><a href="#Node-js特点" class="headerlink" title="Node.js特点"></a>Node.js特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">(1) 单线程逻辑处理</span><br><span class="line">(2) 非阻塞</span><br><span class="line">(3) 异步 I/O 处理</span><br><span class="line">(4) 事件驱动编程</span><br></pre></td></tr></table></figure><h3 id="Node-js运行模式-两种"><a href="#Node-js运行模式-两种" class="headerlink" title="Node.js运行模式(两种)"></a>Node.js运行模式(两种)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1) 交互模式 -- 用于测试</span><br><span class="line">    node.js子代的模块无需引入，可以直接使用</span><br><span class="line">    +执行方法：</span><br><span class="line">      - cmd 或 git bash</span><br><span class="line">      - node           // 进入node 环境</span><br><span class="line">      - 输入 js 代码，回车执行</span><br><span class="line">(2) 脚本模式 -- 用于开发</span><br><span class="line">    把要执行的 js语句编写在一个js 文件中，一次性交给 node.js 解释器执行</span><br><span class="line">    脚本模式下，使用node.js自带的模块，需要 require()引入</span><br><span class="line">    +执行方法：</span><br><span class="line">      - node 文件路径(不是js后缀也可)</span><br><span class="line">(3) 也可在编译器，比如 webstorm里右键 Run &apos;xxx.js&apos; 运行</span><br></pre></td></tr></table></figure><h3 id="Node-js的基础语法"><a href="#Node-js的基础语法" class="headerlink" title="Node.js的基础语法"></a>Node.js的基础语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型</span><br><span class="line">(1) 原始类型</span><br><span class="line">    string , number, boolean, null, undefined</span><br><span class="line">(2) 引用类型</span><br><span class="line">    包含 ES 原生对象，Node.js对象，用户自定义对象，需要用 new 关键字创建</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      NodeJs学习
    
    </summary>
    
      <category term="NodeJs" scheme="http://yoursite.com/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="http://yoursite.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>call和apply</title>
    <link href="http://yoursite.com/2017/09/25/call%E5%92%8Capply/"/>
    <id>http://yoursite.com/2017/09/25/call和apply/</id>
    <published>2017-09-25T01:46:18.000Z</published>
    <updated>2018-02-05T05:42:43.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call:</span><br><span class="line">语法：</span><br><span class="line">call(thisObj，<span class="built_in">Object</span>)</span><br><span class="line">定义：</span><br><span class="line">调用一个对象的一个方法，以另一个对象替换当前对象。</span><br><span class="line">说明：</span><br><span class="line">call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的</span><br><span class="line">对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</span><br><span class="line">如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apply方法：</span><br><span class="line">语法：</span><br><span class="line">apply(thisObj，[argArray])</span><br><span class="line">定义：</span><br><span class="line">应用某一对象的一个方法，用另一个对象替换当前对象。</span><br><span class="line">说明：</span><br><span class="line">如果 argArray 不是一个有效的数组或者不是 <span class="built_in">arguments</span> 对象，那么将导致一个 <span class="built_in">TypeError</span>。</span><br><span class="line">如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj，</span><br><span class="line"> 并且无法被传递任何参数。</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind函数元素：</span><br><span class="line">    创建一个新函数，在新函数中调用原函数，用call替换原函数中的<span class="keyword">this</span></span><br><span class="line">    而且，替换 <span class="keyword">this</span> 的对象被闭包固定在新函数【bind 函数的原理】</span><br></pre></td></tr></table></figure><h3 id="call-和-apply-和-bind"><a href="#call-和-apply-和-bind" class="headerlink" title="call 和 apply 和 bind"></a>call 和 apply 和 bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">call 和 apply 没有兼容性问题，bind 不兼容 ie8 一下</span><br><span class="line">call 和 apply：临时借用函数，并替换函数中的<span class="keyword">this</span></span><br><span class="line">调用函数</span><br><span class="line">    参数：</span><br><span class="line">        call:所有参数单独传入</span><br><span class="line">        apply:所有参数放入数组中集中传入</span><br><span class="line">bind:创建函数，永久绑定函数中的<span class="keyword">this</span></span><br></pre></td></tr></table></figure><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">如：现有一个薪资计算器函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">base,bonus</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>总工资是<span class="subst">$&#123;base+bonus&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lilei = &#123;<span class="attr">name</span>:<span class="string">'lilei'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> hmm = &#123;<span class="attr">name</span>:<span class="string">'han Meimei'</span>&#125;;</span><br><span class="line"><span class="comment">//   现在 lilei 和 hmm 都用一次calc 方法</span></span><br><span class="line"><span class="comment">//   call 方法在调用瞬间，会把 this 指向当前调用的对象【是暂时的借用】</span></span><br><span class="line">calc.call(lilei,<span class="number">1000</span>,<span class="number">500</span>);      <span class="comment">// lilei总工资是 1500</span></span><br><span class="line">calc.call(hmm,<span class="number">1000</span>,<span class="number">600</span>);        <span class="comment">// lilei总工资是 1600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   如果给lilei， bind(lilei)永久绑定一个专属的薪资计算器函数</span></span><br><span class="line"><span class="comment">//   bind(lilei);相当于把 this 永久性的绑定给了 lilei,给 lilei 复制了一个calc 方法</span></span><br><span class="line"><span class="keyword">var</span> lilei_calc = calc.bind(lilei);</span><br><span class="line">lilei_calc(<span class="number">1000</span>,<span class="number">500</span>);          <span class="comment">// lilei总工资是 1500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   这时 hmm 调用不了 lilei 的方法</span></span><br><span class="line">lilei_calc.call(hmm,<span class="number">1000</span>,<span class="number">600</span>);  <span class="comment">// lilei总工资是 1600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   还可以调用原始的 calc 方法</span></span><br><span class="line">calc.call(hmm,<span class="number">1000</span>,<span class="number">600</span>);  <span class="comment">// han Meimei总工资是 1600</span></span><br><span class="line"></span><br><span class="line">--------------------------------- bind() 兼容解决 ---------------------------------------</span><br><span class="line">bind 完整的实现原理【ie8】</span><br><span class="line">方法一：</span><br><span class="line"><span class="comment">//   只能用闭包的方式解决【比较难理解】</span></span><br><span class="line"><span class="comment">//   用上面的例子来注释,实现 bind()兼容</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Function</span>.prototype.bind === <span class="literal">undefined</span>)&#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fun = <span class="keyword">this</span>;     <span class="comment">//  先将原函数 calc,另存到变量 fun 中</span></span><br><span class="line">        <span class="comment">//  返回一个新的内层函数对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="regexp">/* arguments */</span></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//  在新内层函数中借用fun 引用的原函数</span></span><br><span class="line">            <span class="comment">//  用指定对象 obj 替换 fun 引用的原函数中的 this</span></span><br><span class="line">            <span class="comment">//  接收所有传入新函数的参数，打散后传给 fun 函数</span></span><br><span class="line">            <span class="comment">//  arguments 接住了所有参数(不确定几个),arguments是个集合，所以用 apply</span></span><br><span class="line">            fun.apply(obj,<span class="built_in">arguments</span>);   <span class="comment">//  obj.calc();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二【ie8】：</span><br><span class="line">可以在 bind() 里传入多个参数;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Function</span>.prototype.bind === <span class="literal">undefined</span>)&#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">obj<span class="regexp">/*,args*/</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fun = <span class="keyword">this</span>; <span class="comment">// this -&gt;calc  fun -&gt;calc</span></span><br><span class="line">        <span class="keyword">var</span> arg1 = <span class="comment">//保存除了obj外的剩余参数到 args1</span></span><br><span class="line">            <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="regexp">/*args2*/</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> arg2 = <span class="comment">//复制后传入的新参数到 args2</span></span><br><span class="line">                <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">                       <span class="comment">//将新旧参数拼起来，一起传给 fun</span></span><br><span class="line">            fun<span class="comment">/*calc*/</span>.apply(obj,args1.concat(args2))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="concat-和apply"><a href="#concat-和apply" class="headerlink" title="concat 和apply"></a>concat 和apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">顺便记录一下 concat 和 apply 的区别</span><br><span class="line">首先，concat 和 apply 都可以打散数组，</span><br><span class="line">    concat不好的地方就是返回新数组，就数组仍在内存中，有点浪费内存</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      call()与apply()区别
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js多态</title>
    <link href="http://yoursite.com/2017/09/25/js%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2017/09/25/js多态/</id>
    <published>2017-09-25T01:40:08.000Z</published>
    <updated>2017-10-14T02:09:52.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js多态"><a href="#js多态" class="headerlink" title="js多态"></a>js多态</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">多态的基本概念：一个引用类型（变量）在不同情况下的多种状态。</span><br><span class="line">js本身是无态的，天生就支持多态。</span><br><span class="line"></span><br><span class="line"><span class="comment">//Master类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Master</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="comment">//方法[给动物喂食物]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型法添加成员函数</span></span><br><span class="line">Master.prototype.feed=<span class="function"><span class="keyword">function</span>(<span class="params">animal,food</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(<span class="string">"给"</span>+animal.name+<span class="string">"喂"</span>+food.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;     <span class="comment">//猫猫</span></span><br><span class="line">    <span class="keyword">this</span>.animal=Animal;</span><br><span class="line">    <span class="keyword">this</span>.animal(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;     <span class="comment">//狗狗</span></span><br><span class="line">    <span class="keyword">this</span>.animal=Animal;</span><br><span class="line">    <span class="keyword">this</span>.animal(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fish</span>(<span class="params">name</span>)</span>&#123;    <span class="comment">//鱼</span></span><br><span class="line">    <span class="keyword">this</span>.food=Food;</span><br><span class="line">    <span class="keyword">this</span>.food(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bone</span>(<span class="params">name</span>)</span>&#123;    <span class="comment">//骨头</span></span><br><span class="line">    <span class="keyword">this</span>.food=Food;</span><br><span class="line">    <span class="keyword">this</span>.food(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个主人</span></span><br><span class="line"><span class="keyword">var</span> master=<span class="keyword">new</span> Master();</span><br><span class="line">master.feed(cat,fish);</span><br><span class="line">master.feed(dog,bone);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js多态
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Array/String/RegExp/Math/Date</title>
    <link href="http://yoursite.com/2017/09/24/Array,String,RegExp,Math,Date/"/>
    <id>http://yoursite.com/2017/09/24/Array,String,RegExp,Math,Date/</id>
    <published>2017-09-24T05:29:09.000Z</published>
    <updated>2017-10-14T02:09:52.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回忆数组API"><a href="#回忆数组API" class="headerlink" title="回忆数组API"></a>回忆数组API</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// arr.join() 无缝拼接,动态生成有格式的内容</span></span><br><span class="line">arr.join(<span class="string">''</span>);</span><br><span class="line">-----------------------------arr.concat()-----------------------------------</span><br><span class="line"><span class="comment">// arr.concat(); 无权修改原数组，只能返回新数组,必须用变量接;</span></span><br><span class="line"><span class="comment">// 特点 : 打散数组类型的参数为单个元素</span></span><br><span class="line"><span class="keyword">var</span> newArray = arr.concat(值<span class="number">1</span>，值<span class="number">2</span>,arr1...);</span><br><span class="line">-----------------------------arr.slice(starti,endi+<span class="number">1</span>)-----------------------------------</span><br><span class="line"><span class="comment">// arr.slice(starti,endi+1);</span></span><br><span class="line">只能返回新数组,必须用变量接,返回 starti到endi+<span class="number">1</span>中间的元素,支持负数下标,含头不含尾;</span><br><span class="line">endi+<span class="number">1</span>可省略，省略后默认截取starti以后的所有元素</span><br><span class="line">如果两个参数都省略，相当于复制一遍数组</span><br><span class="line">------------------------------arr.splice()-----------------------------------</span><br><span class="line"><span class="comment">// arr.splice() 删除/插入/替换</span></span><br><span class="line">删除数据中指定位置的元素:  arr.splice(starti,n);    <span class="comment">// 返回删除以后的剩余元素</span></span><br><span class="line">以下两点为 广告轮播数组的核心算法;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">//  删除开头两个，再拼接到结尾：</span></span><br><span class="line">arr = arr.concat(arr.splice(<span class="number">0</span>,<span class="number">2</span>));           <span class="comment">//[3,4,5,1,2]</span></span><br><span class="line"><span class="comment">//  删除结尾的2个元素，再拼接到 arr 开头：</span></span><br><span class="line">arr = arr.splice(arr.length<span class="number">-2</span>,<span class="number">2</span>).concat(arr);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line">在数组指定位置插入新元素</span><br><span class="line"><span class="comment">//在starei 位置插入新值，原 starti 位置的值被向后顺移</span></span><br><span class="line">arr.splice(starti,<span class="number">0</span>,值<span class="number">1</span>,值<span class="number">2</span>,...)</span><br><span class="line"></span><br><span class="line">替换数组中指定位置的元素</span><br><span class="line">先删除starti位置的 n 个旧元素，再在starti位置插入新值</span><br><span class="line">arr.splice(starti, n, 值<span class="number">1</span>, 值<span class="number">2</span>，...);</span><br><span class="line">----------------------------判断一个元素是否存在于一个数组中---------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInArray</span>(<span class="params">arr,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value === arr[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------arr.reverse();翻转----------------------------------</span><br><span class="line">直接修改原数组;</span><br><span class="line">-------------------------------自定义 <span class="built_in">String</span>( ) 方法，替换toString()----------------------------------</span><br><span class="line"><span class="built_in">String</span> vs toString      <span class="built_in">String</span>万能</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">String</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//undefined放在前面判断，是为了避免误判，因为当类型为 undefined时，此类型也 == null</span></span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'undefined'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'null'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取数组最大值"><a href="#取数组最大值" class="headerlink" title="取数组最大值"></a>取数组最大值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMax</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,max=arr[<span class="number">0</span>]; i&lt;arr.length; arr[i]&gt;max&amp;&amp;(max=arr[i]),i++);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getMax(arr));   <span class="comment">//3</span></span><br><span class="line"><span class="comment">//  for循环中如果循环体只有一句话的情况下，可以被放入for循环中。</span></span><br></pre></td></tr></table></figure><h3 id="数组元素交换位置的方法"><a href="#数组元素交换位置的方法" class="headerlink" title="数组元素交换位置的方法"></a>数组元素交换位置的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">-----方法<span class="number">1</span>(使用第三个变量)------</span><br><span class="line"><span class="keyword">var</span> t = a; a = b; b = t;</span><br><span class="line">-----方法<span class="number">2</span>(异或，只能交换数字)------</span><br><span class="line"><span class="keyword">var</span> a ^= b; b ^= a; a ^= b;</span><br><span class="line">-----方法<span class="number">3</span>(做加减，只能交换数字)------</span><br><span class="line">a += b; b = a-b; a -= b;</span><br><span class="line">-----方法<span class="number">4</span>(万能)------</span><br><span class="line">a=[b,b=a][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------冒泡排序(升序)-------------------------------------</span><br><span class="line">冒泡排序算法：</span><br><span class="line"><span class="comment">// 遍历数组，r&lt;length-1;拿当前元素和下一个元素做比较，</span></span><br><span class="line"><span class="comment">// 如果当前元素大于下一个元素，交换两个元素位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 外层控制循环次数 从 r = 1 开始,到length-r 结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> r=<span class="number">1</span>; r&lt;arr.length-r; r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length-r; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 异或，交换位置，异或只能交换 number</span></span><br><span class="line">                arr[i]^=arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>]^=arr[i];</span><br><span class="line">                arr[i]^=arr[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bubbleSort(arr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(arr));   <span class="comment">//1,2,3,4,5,6,7</span></span><br><span class="line">固定套路:</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;); <span class="comment">//[1,2,3,4,5,6,7]</span></span><br><span class="line">-----------------------------------快速排序-------------------------------------</span><br><span class="line"></span><br><span class="line">-----------------------------------插入排序-------------------------------------</span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 以下两种方法都用这组数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,arr=[]; i&lt;<span class="number">100000</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 获得十万个 0 - 999随机数生成数组arr</span></span><br><span class="line">    arr[arr.length] = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">-------------------------- 方法 <span class="number">1</span> ----------------------------</span><br><span class="line"><span class="comment">// 1. 遍历 arr 同时声明空数组 uarr</span></span><br><span class="line"><span class="comment">// 2. 遍历 uarr , 如果当前的 arr的值 等于 uarr的值，说明有重复，退出次此轮循环</span></span><br><span class="line"><span class="comment">// 3. 如果 uarr 的下标 等于 uarr.length,说明uarr中没有与arr中相同的元素，那么将此元素压入uarr;</span></span><br><span class="line"><span class="comment">// 4. 遍历结束，返回 新数组uarr;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique1</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,uarr=[]; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;uarr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uarr[j] == arr[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == uarr.length)&#123;</span><br><span class="line">            uarr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uarr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> uarr = unique1(arr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(uarr)); <span class="comment">//   已去重</span></span><br><span class="line">-------------------------- 方法 <span class="number">2</span> ----------------------------</span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. 遍历 arr 同时声明空数组 hash</span></span><br><span class="line"><span class="comment">// 2. 如果 hash 里以 arr 当前元素作为key的 值为 undefined,就赋值为 1；</span></span><br><span class="line"><span class="comment">// 3. 遍历结束，将 i 置为0，重新定义空数组用于保存提取的 key</span></span><br><span class="line"><span class="comment">// 4. for (keys[i++] in hash); 遍历取出hash中的key并返回 keys 数组，达到去重目的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique2</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,hash=[]; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 如果 hash 中以arr当前元素值为 key 的元素 等于 undefined</span></span><br><span class="line">        <span class="keyword">if</span>(hash[arr[i]] === <span class="literal">undefined</span>)&#123;</span><br><span class="line">            hash[arr[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 遍历结束 ['a':1,'b':1,'c':1]</span></span><br><span class="line">    i =<span class="number">0</span>;                   <span class="comment">// 设置 i=0</span></span><br><span class="line">    <span class="keyword">var</span> keys = [];          <span class="comment">//定义空数组keys</span></span><br><span class="line">    <span class="keyword">for</span>(keys[i++] <span class="keyword">in</span> hash); <span class="comment">//专用于取出 hash中的 key</span></span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> uarr = unique2(arr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(uarr)); <span class="comment">//   已去重</span></span><br><span class="line">-------------------------- 方法<span class="number">1</span> VS 方法<span class="number">2</span>----------------------------</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'unique1'</span>);</span><br><span class="line">unique1(arr);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'unique1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'unique2'</span>);</span><br><span class="line">unique2(arr);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'unique2'</span>);</span><br><span class="line">结论：</span><br><span class="line">unique1耗时：<span class="number">98</span>ms      unique2耗时：<span class="number">10</span>ms      unique2完胜</span><br><span class="line">并且，如果arr内元素为 number类型的话，unique2返回的数据是升序</span><br><span class="line"></span><br><span class="line">----------------------------- 其他方法(通过 indexOf检索) --------------------------</span><br><span class="line"><span class="comment">// 在数组原型上添加 去重方法</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,n=[]; i&lt;<span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        n.indexOf(<span class="keyword">this</span>[i]) == <span class="number">-1</span> &amp;&amp; n.push(<span class="keyword">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.fn1());</span><br><span class="line">----------------------------- 其他方法等等 --------------------------</span><br></pre></td></tr></table></figure><h3 id="关联-hash数组"><a href="#关联-hash数组" class="headerlink" title="关联/hash数组"></a>关联/hash数组</h3><p>创建关联数组，必须先创建一个空数组，不能直接创建创建关联数组<br>原理:     接收一个字符串，并计算出尽量不重复的序号。<br>存入数据:   hash算法接收一个字符串的下标名，将数据存储在序号对应的数组位置上<br>如何获取：  通过hash算法，算出和存入完全相同的序号，直接去序号位置查找元素。<br>有点：   查找极快<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array();</span><br><span class="line">arr['name'] = '成龙';</span><br><span class="line">arr['age'] = 18;</span><br><span class="line">arr['math'] = 60;</span><br><span class="line"></span><br><span class="line">遍历  for (var key in hash) &#123;  console.log(key+':'+hash[key])  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="indexOf-arr-val-fromi"><a href="#indexOf-arr-val-fromi" class="headerlink" title="indexOf (arr, val, fromi);"></a>indexOf (arr, val, fromi);</h3><p>从某位置开始找某元素，没有找到返回-1，否则返回元素下标<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">arr,val,fromi</span>)</span>&#123;</span><br><span class="line">    fromi === <span class="literal">undefined</span>&amp;&amp;(fromi=<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> ( ; fromi&lt;arr.length; fromi++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[fromi] == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> fromi;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 1位置开始找元素为 3的下标</span></span><br><span class="line"><span class="built_in">console</span>.log(indexOf(arr,<span class="number">3</span>,<span class="number">1</span>));  <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><h3 id="引用类型的对象和原始类型的值"><a href="#引用类型的对象和原始类型的值" class="headerlink" title="引用类型的对象和原始类型的值"></a>引用类型的对象和原始类型的值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---------引用类型的对象(在内存中引用的是同一个地址)---------</span><br><span class="line"><span class="comment">// 引用类型的对象：用原变量修改对象，新变量同样受影响</span></span><br><span class="line"><span class="comment">// 因为两个变量引用的是同一个对象</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr;</span><br><span class="line">arr.length--;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);    <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length);   <span class="comment">//4</span></span><br><span class="line">arr1.length--;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);    <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length);   <span class="comment">//3</span></span><br><span class="line">-------------------------原始类型的值----------------------------</span><br><span class="line"><span class="keyword">var</span> money = <span class="number">10</span>;</span><br><span class="line"> <span class="comment">// 这时，参数money是副本，值是10;</span></span><br><span class="line"> <span class="comment">// 原始类型的值：修改新变量不会影响原变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> money-=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">buy(money);         <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(money); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h3 id="字符串API"><a href="#字符串API" class="headerlink" title="字符串API"></a>字符串API</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-----------大小写转换----------</span><br><span class="line">str.toUpperCase();</span><br><span class="line">str.toLowerCase();</span><br><span class="line">-----------str.chartAt()----------</span><br><span class="line">获取指定位置的字符</span><br><span class="line">str.chartAt(i)  =&gt;  str[i]</span><br><span class="line">获得str位置中i 位置的字符的 unicode 号</span><br><span class="line">str.chartCodeAt(i);</span><br><span class="line">--------------字符串截取---------------</span><br><span class="line">str.slice(starti,end+<span class="number">1</span>);     <span class="comment">//支持负数参数</span></span><br><span class="line">str.substring(starti,endi+<span class="number">1</span>);<span class="comment">//不支持负数参数，可用 length - n;</span></span><br></pre></td></tr></table></figure><h3 id="检索敏感词"><a href="#检索敏感词" class="headerlink" title="检索敏感词"></a>检索敏感词</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'no zuo no die no can no bibi'</span>;</span><br><span class="line">           <span class="number">4</span>      <span class="number">7</span>     <span class="number">14</span>     <span class="number">21</span></span><br><span class="line"><span class="comment">// indexOf 从前往后找</span></span><br><span class="line">------------------<span class="comment">// indexOf 从前往后找(不支持负数参数，给负数参数就变为0)--------------------</span></span><br><span class="line"><span class="comment">// 原理:每次循环，在当前敏感词+1的位置重新开始找</span></span><br><span class="line"><span class="comment">// 反复查找 str 中每个 no 出现的位置</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>( (i=str.indexOf(<span class="string">'no'</span>,i+<span class="number">1</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'在位置'</span>+i+<span class="string">'发现敏感词'</span>);</span><br><span class="line">&#125;</span><br><span class="line">------------------<span class="comment">// lastIndexOf 从后往前找(不支持负数参数，给负数参数就变为0)-----------------</span></span><br><span class="line"><span class="comment">// 找不到会返回 -1</span></span><br><span class="line"><span class="keyword">var</span> i=str.length;</span><br><span class="line"><span class="keyword">while</span>( (i=str.lastIndexOf(<span class="string">'no'</span>,i<span class="number">-1</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">//关键词位置         下次起始位置</span></span><br><span class="line">       <span class="number">21</span>                      <span class="number">20</span></span><br><span class="line">       <span class="number">14</span>                      <span class="number">13</span></span><br><span class="line">       <span class="number">7</span>                       <span class="number">6</span></span><br><span class="line">       <span class="number">0</span>                       <span class="number">-1</span>  <span class="number">0</span> <span class="comment">// 不支持负数参数，给负数参数就变为0</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'在位置'</span>+i+<span class="string">'发现敏感词'</span>);</span><br><span class="line">    <span class="comment">//  找到0,就返回,否则死循环</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>就是封装一条正则表达式，提供了使用正则执行查找和验证的API。<br>只要使用正则表达式，都要先创建正则表达式对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">创建：</span><br><span class="line"><span class="number">1.</span> 直接量：<span class="keyword">var</span> reg = <span class="regexp">/正则表达式/ig</span>;</span><br><span class="line"><span class="comment">//  字符冲突：正则表达式中的/，都要转义为\/</span></span><br><span class="line"><span class="comment">//  当正则表达式需要动态拼接的时候，只能用 new RegExp()的方式创建</span></span><br><span class="line"><span class="number">2.</span> 用<span class="keyword">new</span>: <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"正则表达式"</span>，<span class="string">"ig"</span>);</span><br><span class="line"><span class="comment">//  字符冲突："\\d \\s \\w \"  \'"</span></span><br><span class="line">-------------------------------match() 方法,动态拼接----------------------------------</span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">'锄禾'</span>,<span class="string">'白鹭'</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'锄禾日当午，一行白鹭上青天，床前明月光，日日思君不见君'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(names.join(<span class="string">'|'</span>),g);    <span class="comment">// g代表全部</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));                <span class="comment">// 输出匹配正则</span></span><br><span class="line">-------------------------------exec( )----------------------------------</span><br><span class="line">原理： reg对象中有一个 lastIndex=<span class="number">0</span> 属性，规定了exec下次开始查找的位置--不用手动维护</span><br><span class="line">exec 每次执行，做三件事：</span><br><span class="line">    <span class="number">1.</span>将关键词内容放入数组第<span class="number">0</span> 个元素</span><br><span class="line">    <span class="number">2.</span>将关键词的位置，放入数组的index 属性</span><br><span class="line">    <span class="number">3.</span>自动将 reg 的 lastIndex+关键词的长度</span><br><span class="line">        导致下次跳过关键词，找下一个</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'no zuo no die no can no bibi'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/no/ig</span>;</span><br><span class="line"><span class="comment">// 查找每个关键词的内容和位置，固定套路,先声明个空arr</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span>((arr = reg.exec(str)) != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'在位置'</span>+arr.index+<span class="string">'发现敏感词'</span>+arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//  输出所有关键词的 位置 和 内容</span></span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------test( )----------------------------------</span><br><span class="line"><span class="comment">//          匹配开头到结尾的6位数字</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;6&#125;$/</span>;</span><br><span class="line"><span class="comment">//              如果不都由 a-z和0-9，如果不都由A-Za-z,而且都由大小写字母和0-9数字组成</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(?![a-z0-9]+$)(?![A-Za-z]+$)[A-Za-z0-9]&#123;6,8&#125;$/</span>;</span><br><span class="line"><span class="keyword">while</span>(!reg.test(prompt(<span class="string">'输入密码'</span>)))&#123;</span><br><span class="line">    alert(<span class="string">'格式不正确，请重新输入'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;h1&gt;验证通过&lt;/h1&gt;'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="Math-API"><a href="#Math-API" class="headerlink" title="Math(API)"></a>Math(API)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(num)      上取整</span><br><span class="line"><span class="built_in">Math</span>.floor(num)     下取整</span><br><span class="line">    vs  <span class="built_in">parseInt</span>(str):</span><br><span class="line">    floor:参数是 number</span><br><span class="line">    <span class="built_in">parseInt</span>:参数是字符串，去掉number以后的字符，并且做了下取整</span><br><span class="line">    解决：<span class="built_in">parseFloat</span>(),保留小数位</span><br><span class="line"><span class="built_in">Math</span>.round(num)     四舍五入</span><br><span class="line">    vs tiFixed(d):</span><br><span class="line">    round:必须用<span class="built_in">Math</span>直接调用，只能取整</span><br><span class="line">    toFixed(d):可被任意数字类型的值调用，可按小数位数四舍五入(范围是<span class="number">0</span><span class="number">-20</span>位),</span><br><span class="line">             他的返回值为字符串，在需要做计算的情况下，需要先转number再做计算</span><br><span class="line">-----------------自定义 round 方法,既保留小数位，又是number 类型，可做运算---------------------</span><br><span class="line">开平方：<span class="built_in">Math</span>.sqrt(num); 乘方：<span class="built_in">Math</span>.pow(底数，幂数);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">round</span>(<span class="params">num,d</span>) </span>&#123;</span><br><span class="line"><span class="comment">//  num * 10 的 d 次方</span></span><br><span class="line"><span class="comment">//  对新的 num 四舍五入取整</span></span><br><span class="line"><span class="comment">//  num / 10 的 d 次方</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isNaN</span>(num) &amp;&amp; !<span class="built_in">isNaN</span>(d))&#123;</span><br><span class="line">        num *= <span class="built_in">Math</span>.pow(<span class="number">10</span>,d);</span><br><span class="line">        num = <span class="built_in">Math</span>.round(num);</span><br><span class="line">        num /= <span class="built_in">Math</span>.pow(<span class="number">10</span>,d);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'参数必须是数字'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(round(<span class="number">345.678</span>,<span class="number">2</span>));  <span class="comment">// 345.68</span></span><br><span class="line">---------------------------<span class="built_in">Math</span>.max()/<span class="built_in">Math</span>.min()----------------------------</span><br><span class="line">不支持传入数组；</span><br><span class="line">解决方案：</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr);   <span class="comment">// 获得最大值</span></span><br><span class="line"><span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,arr);   <span class="comment">// 获得最小值</span></span><br><span class="line"></span><br><span class="line">------------------------生成双色球 demo------------------------</span><br><span class="line">要求：<span class="number">6</span>位升序 <span class="number">1</span><span class="number">-33</span>范围的红球 | 一颗 <span class="number">1</span><span class="number">-16</span>范围 篮球;</span><br><span class="line">思路：</span><br><span class="line"><span class="comment">//  1.声明一个用来放红球的空数组</span></span><br><span class="line"><span class="comment">//  2.while 循环，如果红球没有够 6位长度，做以下操作</span></span><br><span class="line"><span class="comment">//  3.首先声明一个随机数，开始遍历红球数组，如果红球里有和 i随机数一样的元素，那么退出本轮循环</span></span><br><span class="line"><span class="comment">//  4.如果 i 等于红球数组长度，说明 i 遍历结束，没有找到相同元素，此时把 r 压入 reds 中;</span></span><br><span class="line"><span class="comment">//  5.排序，拼接，返回数组;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleball</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reds = [];</span><br><span class="line">    <span class="keyword">while</span>(reds.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">34</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;reds.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(reds[i] == r) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == reds.length) &#123;reds.push(r);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reds.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;);</span><br><span class="line">    <span class="keyword">var</span> blue = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">17</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(reds)+<span class="string">'|'</span>+blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write (<span class="string">'&lt;h1&gt;'</span>+doubleball()+<span class="string">'&lt;/h1&gt;'</span>);</span><br></pre></td></tr></table></figure><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">日期对象的原理：</span><br><span class="line">日期对象中封装的是 <span class="number">1970</span> 年 <span class="number">1</span>月 <span class="number">1</span>日 <span class="number">0</span>点至今的毫秒数</span><br><span class="line">每个分量都有一对  getXXX / set方法</span><br><span class="line">如:修改date日期为 <span class="number">10</span> 号，date.setDate(<span class="number">10</span>);特例：Day没set方法，星期只读，不可改</span><br><span class="line">--------------------------取值范围---------------------------</span><br><span class="line">只有月中的日(<span class="built_in">Date</span>)从 <span class="number">1</span> 开始到 <span class="number">31</span> 结束</span><br><span class="line">其余单位都从 <span class="number">0</span> 开始，到进制 <span class="number">-1</span>结束</span><br><span class="line">Month <span class="number">0</span> - <span class="number">11</span> 比现实中都小<span class="number">1</span> 需要修正</span><br><span class="line"><span class="built_in">Date</span>  <span class="number">1</span> - <span class="number">31</span></span><br><span class="line">Day   <span class="number">0</span> - <span class="number">6</span>  星期日是 <span class="number">0</span> 不用修正</span><br><span class="line">Minutes,Seconds <span class="number">0</span> - <span class="number">59</span> 不用修正</span><br><span class="line"><span class="keyword">var</span> data = newDate();</span><br><span class="line"><span class="comment">// 保留旧的时间</span></span><br><span class="line"><span class="keyword">var</span> oldDate = <span class="keyword">new</span> <span class="built_in">Date</span>(data.getTime()); <span class="comment">//获得毫秒数</span></span><br><span class="line">oldDate.toLocaleString();               <span class="comment">//toLocaleString()转换为  xxxx/xx/xx 下午xx:xx:xx  格式</span></span><br><span class="line"><span class="comment">// 然后对任意分量做加减</span></span><br><span class="line">------------------------重写toLocaleString()方法 -------------------------</span><br><span class="line">希望转换为想要的格式</span><br><span class="line"><span class="built_in">Date</span>.prototype.toLocaleString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.getFullYear() + <span class="string">"年"</span> + (<span class="keyword">this</span>.getMonth() + <span class="number">1</span>) + <span class="string">"月"</span> + <span class="keyword">this</span>.getDate() + <span class="string">"日 "</span> +</span><br><span class="line">       <span class="keyword">this</span>.getHours() + <span class="string">"点"</span> + <span class="keyword">this</span>.getMinutes() + <span class="string">"分"</span> + <span class="keyword">this</span>.getSeconds() + <span class="string">"秒"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">oldDate.toLocaleString(); <span class="comment">//    返回  xxxx年xx月xx日 xx点xx分xx秒</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js基础
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>jquery的一些使用技巧</title>
    <link href="http://yoursite.com/2017/09/22/jquery%E8%BF%90%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/09/22/jquery运用小技巧/</id>
    <published>2017-09-22T14:09:34.000Z</published>
    <updated>2018-02-05T06:21:06.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jq扩展方法"><a href="#jq扩展方法" class="headerlink" title="jq扩展方法"></a>jq扩展方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">比如一个简单的小插件</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">   $.fn.AlertSelf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert($(<span class="keyword">this</span>).html())&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)(jQuery)</span><br><span class="line"></span><br><span class="line">在页面加载完后给某些元素绑定上</span><br><span class="line">&lt;ul id=<span class="string">"OnlyUl"</span>&gt;</span><br><span class="line">   &lt;li&gt;aaa&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">   &lt;li&gt;bbb&lt;/</span>li&gt;</span><br><span class="line">   &lt;li&gt;ccc&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">$(<span class="string">"#OnlyUl li"</span>).AlertSelf();</span><br><span class="line">-------------------------分割线-------------------------</span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">'hello world'</span>) &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'xxx'</span>).event(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.fn.hello();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="jq将数据转化为json字符串，再转化回来"><a href="#jq将数据转化为json字符串，再转化回来" class="headerlink" title="jq将数据转化为json字符串，再转化回来"></a>jq将数据转化为json字符串，再转化回来</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jquery添加数组对象转化字符串方法</span></span><br><span class="line"> $.fn.stringifyArray = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(array);</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转化为数组对象方法</span></span><br><span class="line">$.fn.parseArray = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(array)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">""</span>).stringifyArray(arr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);  <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// [6,5,7,3,9,1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = $(<span class="string">""</span>).parseArray(a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(b);         <span class="comment">// 数组对象</span></span><br></pre></td></tr></table></figure><h3 id="实际上是拥有两个参数的"><a href="#实际上是拥有两个参数的" class="headerlink" title="$()实际上是拥有两个参数的"></a>$()实际上是拥有两个参数的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择一个元素。第二个参数是限制搜索的上下文</span></span><br><span class="line"><span class="comment">// 可以使用选择器，jQuery对象或dom元素</span></span><br><span class="line"></span><br><span class="line">$（<span class="string">' li '</span>，<span class="string">' #firstList '</span> ）.each（<span class="function"><span class="keyword">function</span>（）</span>&#123;</span><br><span class="line">    log（$（<span class="keyword">this</span> ）.html（））;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="新窗口打开链接"><a href="#新窗口打开链接" class="headerlink" title="新窗口打开链接"></a>新窗口打开链接</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"a[href^='http']"</span>).attr(<span class="string">'target'</span>,<span class="string">'_blank'</span>);</span><br></pre></td></tr></table></figure><h3 id="jQuery预加载图像"><a href="#jQuery预加载图像" class="headerlink" title="jQuery预加载图像"></a>jQuery预加载图像</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jQuery.preloadImagesInWebPage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> ctr = <span class="number">0</span>; ctr &amp; lt; <span class="built_in">arguments</span>.length; ctr++) &#123;</span><br><span class="line">    jQuery(<span class="string">""</span>).attr(<span class="string">"src"</span>, <span class="built_in">arguments</span>[ctr]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：</span></span><br><span class="line">$.preloadImages(<span class="string">"image1.gif"</span>, <span class="string">"image2.gif"</span>, <span class="string">"image3.gif"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查图片是否被加载</span></span><br><span class="line">$(<span class="string">'#imageObject'</span>).attr(<span class="string">'src'</span>, <span class="string">'image1.gif'</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'The image has been loaded…'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="jquery设置全局Loading"><a href="#jquery设置全局Loading" class="headerlink" title="jquery设置全局Loading"></a>jquery设置全局Loading</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局设置：</span></span><br><span class="line">$(<span class="built_in">document</span>).bind(<span class="string">"ajaxSend"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#loading_message"</span>).show();</span><br><span class="line">&#125;).bind(<span class="string">"ajaxComplete"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#loading_message"</span>).hide();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊Ajax请求如果不想呈现Loading,只需增加:global:false即可</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">"Get"</span>,</span><br><span class="line">    url: ***********,</span><br><span class="line">    global: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      jquery的运用技巧
    
    </summary>
    
      <category term="jquery小技巧" scheme="http://yoursite.com/categories/jquery%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2017/09/16/%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2017/09/16/数组/</id>
    <published>2017-09-15T23:26:06.000Z</published>
    <updated>2017-10-14T02:09:52.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="map"><a href="#map" class="headerlink" title="map( );"></a>map( );</h3><p>理解 ：映射/ 1 对 1<br>参数 : [].map(function(value, index, array) { // …   });<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法 : array.map(callback,[ thisObject]);</span></span><br><span class="line">---------------切记，callback需要有<span class="keyword">return</span>值，否则返回<span class="literal">undefined</span>------------------</span><br><span class="line"><span class="comment">// 在实际使用的时候，我们可以利用map方法方便获得对象数组中的特定属性值们。例如:</span></span><br><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"小红"</span>, <span class="string">"email"</span>: <span class="string">"hong@123.com"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"小明"</span>, <span class="string">"email"</span>: <span class="string">"ming@123.com"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">"小林"</span>, <span class="string">"email"</span>: <span class="string">"lin@123.com"</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emails = users.map( <span class="function"><span class="params">user</span> =&gt;</span> user.email );</span><br><span class="line"><span class="built_in">console</span>.log(emails.join(<span class="string">", "</span>)); <span class="comment">// hong@123.com, ming@123.com, lin@123.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以链式操作:</span></span><br><span class="line"><span class="keyword">var</span> emailsZhang = users.map(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// 获得邮件</span></span><br><span class="line">                        <span class="keyword">return</span> user.email;</span><br><span class="line">                    &#125;).filter(<span class="function"><span class="keyword">function</span>(<span class="params">email</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// 筛选出zhang开头的邮件</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="regexp">/^zhang/</span>.test(email);</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(emailsZhang.join(<span class="string">", "</span>)); <span class="comment">// zhang@email.com</span></span><br><span class="line">-----------------------------<span class="built_in">Array</span>.prototype扩展IE6-IE8--------------------------</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.map != <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, length = <span class="keyword">this</span>.length; k &lt; length; k++) &#123;</span><br><span class="line">         arr.push(fn.call(context, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="reduce-tmp-item-index"><a href="#reduce-tmp-item-index" class="headerlink" title="reduce (tmp, item, index);"></a>reduce (tmp, item, index);</h3><p>理解 ：返回计算后的总合<br>用法 ：array.reduce(callback[, initialValue])<br>callback函数接受4个参数 function (previous, current, index, array) {  ../ };<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.reduce ( <span class="function"><span class="keyword">function</span> (<span class="params">tmp, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp + item</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log( result );  <span class="comment">//从数组起始到结束累加的效果 17</span></span><br><span class="line">-----------------------------分割线------------------------------</span><br><span class="line">又或者求平均数</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> avg = arr.reduce( <span class="function"><span class="keyword">function</span> (<span class="params">tmp, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( index != arr.length<span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> tmp + item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ( tmp + item ) / arr.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log( avg );</span><br><span class="line">--------------------------实现二维数组扁平化-----------------------------</span><br><span class="line"><span class="keyword">let</span> matrix = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 二维数组扁平化</span></span><br><span class="line"><span class="keyword">let</span> flatten = matrix.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">previous, current</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> previous.concat(current);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">------------------------------<span class="built_in">Array</span>.prototype扩展IE6-IE8--------------------------------</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.reduce != <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span> (<span class="params">callback, initialValue </span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> previous = initialValue, k = <span class="number">0</span>, length = <span class="keyword">this</span>.length;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> initialValue === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        previous = <span class="keyword">this</span>[<span class="number">0</span>];</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (k; k &lt; length; k++) &#123;</span><br><span class="line">         <span class="keyword">this</span>.hasOwnProperty(k) &amp;&amp; (previous = callback(previous, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="filte"><a href="#filte" class="headerlink" title="filte"></a>filte</h3><p>作用：过滤 ( 返回布尔值 )<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：array.filter(callback,[ thisObject]);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span> ,<span class="number">3</span> ,<span class="number">-2</span>, <span class="number">5</span> ,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.filter (<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> item%<span class="number">3</span> == <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log( result );  <span class="comment">// 3</span></span><br><span class="line">------------------------------分割线--------------------------------</span><br><span class="line"><span class="keyword">let</span> obj = [</span><br><span class="line">        &#123;<span class="attr">title</span>:<span class="string">'man'</span>,<span class="attr">price</span>:<span class="number">70</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">title</span>:<span class="string">'woman'</span>,<span class="attr">price</span>:<span class="number">900</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">title</span>:<span class="string">'man1'</span>,<span class="attr">price</span>:<span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">title</span>:<span class="string">'woman1'</span>,<span class="attr">price</span>:<span class="number">300</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> result = obj.filter ( <span class="function"><span class="params">json</span> =&gt;</span> json.price &gt;= <span class="number">300</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( result );  <span class="comment">// 输出两个符合判断条件的对象</span></span><br><span class="line">------------------------------<span class="built_in">Array</span>.prototype扩展IE6-IE8--------------------------------</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.filter != <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">"function"</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, length = <span class="keyword">this</span>.length; k &lt; length; k++) &#123;</span><br><span class="line">          fn.call(context, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>) &amp;&amp; arr.push(<span class="keyword">this</span>[k]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach( );"></a>forEach( );</h3><p>作用：循环，迭代<br>用法 ：array.forEach(callback,[ thisObject]);<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>, <span class="number">4</span>].forEach(<span class="built_in">console</span>.log);  <span class="comment">//输出4次  value index [1,2,3,4]</span></span><br><span class="line"><span class="comment">// 对比jQuery中的$.each方法</span></span><br><span class="line">$.each([], <span class="function"><span class="keyword">function</span>(<span class="params">index, value, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// jquery里的三个参数中，index 和 value 顺序刚好相反</span></span><br><span class="line">&#125;);</span><br><span class="line">由此可见:</span><br><span class="line">forEach方法中的<span class="function"><span class="keyword">function</span>回调支持3个参数，</span></span><br><span class="line"><span class="function">第1个是遍历的数组内容；</span></span><br><span class="line"><span class="function">第2个是对应的数组索引，</span></span><br><span class="line"><span class="function">第3个是数组本身。</span></span><br><span class="line"><span class="function">------------------------------下面是个不错的<span class="title">demo</span>--------------------------------</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">database</span> = </span>&#123;</span><br><span class="line">  users: [<span class="string">"张一山"</span>, <span class="string">"杨紫"</span>, <span class="string">"胖子"</span>],</span><br><span class="line">  sendEmail: <span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isValidUser(user)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"你好，"</span> + user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"抱歉，"</span>+ user +<span class="string">"，找错人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isValidUser: <span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^张/</span>.test(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给每个人法邮件</span></span><br><span class="line"><span class="comment">// forEach除了接受一个必须的回调函数参数，</span></span><br><span class="line"><span class="comment">// 还可以接受一个可选的上下文参数（改变回调函数里面的this指向）;</span></span><br><span class="line"><span class="comment">// 如果这第2个可选参数不指定，则使用全局对象代替（在浏览器是为window），严格模式下甚至是undefined.</span></span><br><span class="line"></span><br><span class="line">database.users.forEach(  <span class="comment">// database.users中人遍历</span></span><br><span class="line">  database.sendEmail,    <span class="comment">// 发送邮件</span></span><br><span class="line">  database               <span class="comment">// 使用database代替上面标紫的this</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 你好，张一山</span></span><br><span class="line"><span class="comment">// 抱歉，杨紫，找错人</span></span><br><span class="line"><span class="comment">// 抱歉，胖子，找错人</span></span><br><span class="line">------------------------------<span class="built_in">Array</span>.prototype扩展IE6-IE8--------------------------------</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.forEach != <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, length = <span class="keyword">this</span>.length; k &lt; length; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">"function"</span> &amp;&amp; <span class="built_in">Object</span>.prototype.hasOwnProperty.call(<span class="keyword">this</span>, k)) &#123;</span><br><span class="line">        fn.call(context, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      数组API
    
    </summary>
    
      <category term="Es6" scheme="http://yoursite.com/categories/Es6/"/>
    
    
      <category term="Es6" scheme="http://yoursite.com/tags/Es6/"/>
    
  </entry>
  
  <entry>
    <title>关于webSocket</title>
    <link href="http://yoursite.com/2017/09/15/%E5%85%B3%E4%BA%8EwebSocket/"/>
    <id>http://yoursite.com/2017/09/15/关于webSocket/</id>
    <published>2017-09-15T06:50:24.000Z</published>
    <updated>2017-10-14T02:09:52.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>什么是webSocket?<ul><li>WebSocket 是一种基于TCP 协议；</li><li>HTTP 也是一种基于TCP 协议；</li><li>连接要保持的(时长)还是关闭是由你服务器应用来控制的。</li></ul></li></ul><h3 id="WebSocket和-HTTP-的关系"><a href="#WebSocket和-HTTP-的关系" class="headerlink" title="WebSocket和 HTTP 的关系"></a>WebSocket和 HTTP 的关系</h3><ul><li>它们扯上关系是只是因为：<ul><li>客户端开始建立 WebSocket 连接时要发送一个 header 标记了 Upgrade 的 HTTP 请求，表示请求协议升级。所以服务器端做出响应的简便方法是，直接在现有的 HTTP 服务器软件和现有的端口上实现 WebSocket 协议，重用现有代码（比如解析和认证这个 HTTP 请求。如果在 TCP 协议上实现，这两个功能就要重新实现），然后再回一个状态码为 101 的 HTTP 响应完成握手，再往后发送数据时就没 HTTP 的事了。</li><li>简单说，HTTP只负责建立WebSocket连接。</li></ul></li></ul><h3 id="WebSocket-的优点"><a href="#WebSocket-的优点" class="headerlink" title="WebSocket 的优点"></a>WebSocket 的优点</h3><ul><li>WebSocket 的优势<ul><li>可以建立长链接，链接的时间可由服务端来控制(代替了之前的 ajax轮询(Polling)和Comet技术【ps:频繁请求】)</li><li>能更好的节省服务器资源和带宽并实现真正意义上的实时推送，比如股票和聊天应用</li><li>WebSocket能够在浏览器和服务器之间建立双向连接，赋予浏览器实时通信能力，意味着服务器端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应。</li></ul></li></ul><h3 id="WebSocket-建立过程"><a href="#WebSocket-建立过程" class="headerlink" title="WebSocket 建立过程"></a>WebSocket 建立过程</h3><p>为了建立一个WebSocket连接，客户端浏览器首先要向服务器发起一个HTTP请求，这个请求和通常的HTTP请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的HTTP请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的WebSocket连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><h3 id="WebSocket-兼容"><a href="#WebSocket-兼容" class="headerlink" title="WebSocket 兼容"></a>WebSocket 兼容</h3><ul><li>兼容和解决方案<ul><li>不兼容 ie10 以下版本</li><li>方案一 ：继续用 Comet技术 解决</li><li>方案二 ：express 和 socket.io，开源的WebSocket库，它通过Node.js实现WebSocket服务端，同时也提供客户端JS库。<a href="http://Socket.IO" target="_blank" rel="noopener">http://Socket.IO</a> 支持以事件为基础的实时双向通讯，它可以工作在任何平台、浏览器或移动设备。</li><li>Socket.IO支持4种协议：WebSocket、htmlfile、xhr-polling、jsonp-polling，它会自动根据浏览器选择适合的通讯方式，从而让开发者可以聚焦到功能的实现而不是平台的兼容性，同时Socket.IO具有不错的稳定性和性能。</li></ul></li></ul><h3 id="一个典型WebSocket客户端请求头："><a href="#一个典型WebSocket客户端请求头：" class="headerlink" title="一个典型WebSocket客户端请求头："></a>一个典型WebSocket客户端请求头：</h3><p><img src="https://pic3.zhimg.com/5bfca3aef0010ff9a81a689cb6859c22_b.jpg" alt="“没有正常显示”"></p><p>demo参考(client文件是客户端需要实现的，server文件里是服务端)<br><a href="https://github.com/plhwin/nodejs-socketio-chat" target="_blank" rel="noopener">https://github.com/plhwin/nodejs-socketio-chat</a></p>]]></content>
    
    <summary type="html">
    
      webSocket的理解和运用
    
    </summary>
    
      <category term="webSocket" scheme="http://yoursite.com/categories/webSocket/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>关于webpack(3.8.1)</title>
    <link href="http://yoursite.com/2017/09/15/%E5%85%B3%E4%BA%8Ewebpack/"/>
    <id>http://yoursite.com/2017/09/15/关于webpack/</id>
    <published>2017-09-15T02:11:59.000Z</published>
    <updated>2017-10-20T12:35:03.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先确保 npm 和node【双数后缀稳定版本】的安装</p><blockquote><p>1.cmd -&gt; cd xxx -&gt; mkdir webpack_demo -&gt; cd webpack_demo<br>//全局安装<br>2.npm install -g webpack<br>//初始化的主要目的是生成package.json文件<br>4.npm init<br>//进行项目目录的安装【这里的参数–save是要保存到package.json中，dev是在开发时使用这个包，而生产环境中不使用。】<br>5.npm install –save-dev webpack<br>//查看webpack 版本<br>6.webpack -v</p></blockquote><h3 id="开始demo"><a href="#开始demo" class="headerlink" title="开始demo"></a>开始demo</h3><blockquote><p>1.新建文件 src【用来放源文件，开发环境】和dist【打包后的文件，生产环境】<br>2.dist -&gt; 建立index.html【这里引入了一个JavaScript的bundle.js文件。这个文件现在还没有】，<br>  src -&gt; 建立 entery.js【入口文件，编写js测试代码】<br>3.第一次Webpack打包命令:  webpack src/entry.js dist/bundle.js【打包成功，生成bundle.js】<br>4.查看浏览器显示信息</p></blockquote><h3 id="配置文件：入口和出口"><a href="#配置文件：入口和出口" class="headerlink" title="配置文件：入口和出口"></a>配置文件：入口和出口</h3><p>开发中并不会像上面的demo 那样去打包，而是使用Webpack的配置文件的方式进行设置。</p><blockquote><p>配置文件webpack.config.js<br>1.webpack.config.js就是Webpack的配置文件【手动建立】<br>2.建立好后先写好基本配置如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 这是一个没有内容的标准webpack配置模版。</span></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    <span class="comment">// 配置入口文件的地址，可以是单一入口，也可以是多入口。</span></span><br><span class="line">    entry:&#123;</span><br><span class="line">            entry: <span class="string">'./src/entry.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="comment">// 配置出口文件的地址，在webpack2.X版本后，支持多出口配置。</span></span><br><span class="line">    output:&#123;</span><br><span class="line">            path: path.resolve(__dirname,<span class="string">'dist'</span>),    <span class="comment">// 这里的path(路径) 需要在顶部引入</span></span><br><span class="line">            filename: <span class="string">'bundle.js'</span>                    <span class="comment">// 打包的出口文件名称</span></span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="comment">// 配置模块，主要是解析CSS和图片转换压缩等功能。</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;&#125;,</span><br><span class="line">   <span class="comment">// 配置插件，根据你的需要配置不同功能的插件。</span></span><br><span class="line">    plugins:[],</span><br><span class="line">    <span class="comment">// 配置开发服务功能，后期我们会详细讲解。</span></span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置完成，运行webpack</span></span><br><span class="line"><span class="comment">// 在 index.html 引入bundle.js</span></span><br></pre></td></tr></table></figure></p></blockquote><p>多入口、多出口配置<br>这里需要安装 live-server, npm install -g live-server<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        entry:<span class="string">'./src/entry.js'</span>,</span><br><span class="line">        entry2:<span class="string">'./src/entry2.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;&#125;,</span><br><span class="line">    plugins:[],</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时在index.html 里需要单个引入 打包后的 js 文件</span></span><br></pre></td></tr></table></figure></p><p>这时执行  live-server<br>默认监听 8080端口，这是需要注意的是避免端口冲突<br><img src="/2017/09/15/关于webpack/1.png" alt="“live-server”"></p><h3 id="配置文件：-服务和热更新"><a href="#配置文件：-服务和热更新" class="headerlink" title="配置文件： 服务和热更新"></a>配置文件： 服务和热更新</h3><p>设置webpack-dev-server:<br>要执行webpack-dev-server是要先用npm install webpack-dev-server –save-dev 来进行下载的。<br>下载好后，需要配置一下devServer。<br>最简单的devServer配置项只有四个。先看一下代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">         <span class="comment">//配置服务器基本运行路径，用于找到程序打包地址。</span></span><br><span class="line">    contentBase:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">         <span class="comment">//服务运行地址，建议使用本机IP，这里为了讲解方便，所以用localhost。</span></span><br><span class="line">    host:<span class="string">'localhost'</span>,</span><br><span class="line">         <span class="comment">//服务器端压缩选型，一般设置为开启，如果你对服务器压缩感兴趣，可以自行学习。</span></span><br><span class="line">    compress:<span class="literal">true</span>,</span><br><span class="line">         <span class="comment">//服务运行端口，建议不使用80，很容易被占用，这里使用了1717.</span></span><br><span class="line">    port:<span class="number">1717</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置好后，可以试着在终端中输入webpack-dev-server,如果可以执行成功</span></span><br><span class="line"><span class="comment">// 但是往往提示错误（或者是无法找到内部或外部命令）。</span></span><br></pre></td></tr></table></figure></p><p>报错后配置 package.json：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"webpack-dev-server"</span></span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在终端里输入 npm run server 打开服务器。然后在浏览器地址栏输入http://localhost:1717就可以看到结果了。</span></span><br></pre></td></tr></table></figure></p><h3 id="css文件打包"><a href="#css文件打包" class="headerlink" title="css文件打包"></a>css文件打包</h3><p>优点：减少http的请求数，就是把多个文件打包到一个js里，这样请求数就可以减少好多。<br>在学习CSS打包之前，需要先对webpack.config.js里的Loaders配置项进行了解。</p><blockquote><p>Loaders<br>通过使用不同的Loader，Webpack可以的脚本和工具，从而对不同的文件格式进行特定处理。<br>简单的举几个Loaders使用例子：<br>    可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。<br>    可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。<br>    可以把React中的JSX转换成JavaScript代码。</p></blockquote><p>注意：所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置。</p><p>Loaders的配置型简单梳理:<br>    test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；<br>    use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错；<br>    include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；<br>    query：为loaders提供额外的设置选项（可选）。</p><blockquote><p>打包CSS文件步骤：<br>1.首先/src 下建立一个css文件夹，在里面建立 index.css,输出测试样式<br>2.下载：<br>cnpm install style-loader –save-dev   //下载style-loader<br>cnpm install css-loader –save-dev     //下载css-loader<br>3.配置 webpack.config.js 里的 module如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js 里的 module</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.css/</span>, <span class="comment">//正则找到css 文件</span></span><br><span class="line">                <span class="comment">// use换成loader,可作为第二种使用方法</span></span><br><span class="line">                use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>],</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// npm run server 命令重启端口，css打包成功</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般用第三种，可以加一些配置项</span></span><br><span class="line"><span class="comment">// 这是 loader 的第三种写法【用use+loader的写法】</span></span><br><span class="line"> <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">"style-loader"</span></span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: <span class="string">"css-loader"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="插件配置：配置JS压缩"><a href="#插件配置：配置JS压缩" class="headerlink" title="插件配置：配置JS压缩"></a>插件配置：配置JS压缩</h3><p>开发环境下，不需要压缩，压缩后代码无法调试</p><blockquote><p>压缩JS代码：<br>JS代码，在上线之前，都是需要进行压缩的<br>在Webpack中可以很轻松的实现JS代码的压缩，它是通过插件的方式实现的，这里我们就先来引入一个uglifyjs-webpack-plugin(JS压缩插件，简称uglify)。<br>步骤：<br>1.webpack.congif.js里引入 const uglify = require(‘uglifyjs-webpack-plugin’);<br>2.配置 plugins : [new uglify(),]<br>3.webpack 命令执行压缩操作<br>4.dist文件下的js 压缩成功，如下图</p></blockquote><p><img src="/2017/09/15/关于webpack/2.png" alt="“live-server”"><br><img src="/2017/09/15/关于webpack/3.png" alt="“live-server”"></p><h3 id="插件配置：HTML文件的打包"><a href="#插件配置：HTML文件的打包" class="headerlink" title="插件配置：HTML文件的打包"></a>插件配置：HTML文件的打包</h3><blockquote><p>1.把之前放在 dist里的index.html移动到 src下<br>2.安装打包html 所需插件: cnpm install –save-dev html-webpack-plugin<br>3.webpack.congig.js 顶部引入:const htmlPlugin = require(‘html-webpack-plugin’);  // html 打包需要安装插件<br>4.配置 webpack.config.js 下 plugins:[…]<br>5.删除dist文件，重新执行 webpack 命令打包<br>6.打包成功，输出dist 文件，以及完成index.html打包，自动引入 js/css</p></blockquote><p><img src="/2017/09/15/关于webpack/4.png" alt="“live-server”"><br><img src="/2017/09/15/关于webpack/5.png" alt="“live-server”"></p><h3 id="css中图片处理"><a href="#css中图片处理" class="headerlink" title="css中图片处理"></a>css中图片处理</h3><p>（1）src 下新建 images文件，并放入图片<br>（2）css 中background 写入图片，设置宽高<br>（3）配置 webpack.config.js<br>需要的loader:<br>url-loader  //作用:解决图片引入的url<br>file-loader //作用:解决打包后图片路径不相同的错误<br>使用时暂时只需要使用url-loader,但是他依赖 file-loader</p><p>下载: cnpm install –save-dev file-loader url-loader<br>配置如下图 webpack.config.js：<br>配置完成执行 webpack 命令重新编译<br><img src="/2017/09/15/关于webpack/6.png" alt="“live-server”"></p><h3 id="图片迈坑：CSS分离与图片路径处理"><a href="#图片迈坑：CSS分离与图片路径处理" class="headerlink" title="图片迈坑：CSS分离与图片路径处理"></a>图片迈坑：CSS分离与图片路径处理</h3><p>需要用到插件：extract-text-webpack-plugin<br>这个插件就可以完美的解决我们提取CSS的需求，但是webpack官方其实并不建议这样做，他们认为CSS就应该打包到JavasScript当中以减少http的请求数。</p><p>安装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure></p><p>引入：安装完成后，需要先用require引入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> extractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</span><br></pre></td></tr></table></figure></p><p>设置Plugins：引入成功后需要在plugins属性中进行配置。这里只要new一下这个对象就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> extractTextPlugin(<span class="string">"/css/index.css"</span>)</span><br></pre></td></tr></table></figure></p><p>修改代码如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">              use: extractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">                use: <span class="string">"css-loader"</span></span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">               test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:<span class="string">'url-loader'</span>,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:<span class="number">500000</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>最后注意：<br>需要在 出口配置output 图片文件路径，首先在顶部<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在文件顶部，这里用 ip:端口，声明一个对象</span></span><br><span class="line"><span class="keyword">var</span> website = &#123;</span><br><span class="line">    publicPath:<span class="string">"http://172.16.0.197:1717/"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 output 引用</span></span><br><span class="line"> output:&#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>),    <span class="comment">// 这里的path(路径) 需要在顶部引入</span></span><br><span class="line">        filename: <span class="string">'[name].js'</span>,                    <span class="comment">// 打包的出口文件名称</span></span><br><span class="line">        publicPath: website.publicPath</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// url-loader下面的options设置outputPath:'images/',</span></span><br><span class="line"><span class="comment">// 这样的话，符合limit参数大小的图片就自动转码，不符合的额外处理</span></span><br><span class="line"> options:&#123;</span><br><span class="line">    <span class="comment">//1.文件大小小于limit参数，url-loader将会把文件转为DataURL（Base64格式）；</span></span><br><span class="line">    <span class="comment">//2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。</span></span><br><span class="line">    limit:<span class="number">50000</span>,</span><br><span class="line">    outputPath:<span class="string">'images/'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作完上边这四部后，就可以使用webpack进行打包达成 css与图片分离的作用。</p><h3 id="HTML中的图片打包"><a href="#HTML中的图片打包" class="headerlink" title="HTML中的图片打包"></a>HTML中的图片打包</h3><p>需要： html-withimg-loader<br>下载： cnpm install –save-dev html-withimg-loader<br>配置完成，npm run build 打包，图片正常展现<br>配置：<br><img src="/2017/09/15/关于webpack/22.png" alt="“live-server”"></p><h3 id="打包和分离-Less"><a href="#打包和分离-Less" class="headerlink" title="打包和分离 Less"></a>打包和分离 Less</h3><p>首先安装less和less-loader, cnpm install –save-dev less less-loader<br>scr/css 新建less 文件，写入测试 less 样式，重新打包，重启服务器，效果成功展示<br>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                 test:/\.less$/,</span><br><span class="line">                 use: extractTextPlugin.extract(&#123;</span><br><span class="line">                     use: [&#123;</span><br><span class="line">                         loader: &quot;css-loader&quot;</span><br><span class="line">                     &#125;, &#123;</span><br><span class="line">                         loader: &quot;less-loader&quot;</span><br><span class="line">                     &#125;],</span><br><span class="line">                     // use style-loader in development</span><br><span class="line">                     fallback: &quot;style-loader&quot;</span><br><span class="line">                 &#125;)</span><br><span class="line">             &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>配置好后，会发现less被分离到了index.css文件里。</p><h3 id="打包和分离-Sass"><a href="#打包和分离-Sass" class="headerlink" title="打包和分离 Sass"></a>打包和分离 Sass</h3><p>这里需要 在项目目录下用npm安装两个包。node-sass和sass-loader<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev node-sass <span class="comment">//因为sass-loader依赖于node-sass，所以需要先安装node-sass</span></span><br><span class="line">npm install --save-dev sass-loader</span><br></pre></td></tr></table></figure></p><p>注意：在用npm安装时，这个loader很容易安装失败，最好使用cnpm来进行安装。如果你安装一直报错，最好是把node_modules文件夹删除后，再重新安装。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要注意的是loader的加载要有先后顺序。</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">  use: [&#123;</span><br><span class="line">      loader: <span class="string">"style-loader"</span> <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">      loader: <span class="string">"css-loader"</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">      loader: <span class="string">"sass-loader"</span> <span class="comment">// compiles Sass to CSS</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Sass文件的编写<br>写好loader配置后，就可以愉快的编写sass文件拉，但是不要忘记把sass文件引入到entery.js中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$nav-color: #FFF;</span><br><span class="line">#nav &#123;</span><br><span class="line">  $width: 100%;</span><br><span class="line">  width: $width;</span><br><span class="line">  height:30px;</span><br><span class="line">  background-color: $nav-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>都完成后，你就可以启动我们npm run server 来查看效果了。</p><p>把SASS文件分离。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">  use: extractTextPlugin.extract(&#123;</span><br><span class="line">      use: [&#123;</span><br><span class="line">          loader: <span class="string">"css-loader"</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          loader: <span class="string">"sass-loader"</span></span><br><span class="line">      &#125;],</span><br><span class="line">      <span class="comment">// use style-loader in development</span></span><br><span class="line">      fallback: <span class="string">"style-loader"</span></span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="CSS进阶：自动处理CSS3属性前缀"><a href="#CSS进阶：自动处理CSS3属性前缀" class="headerlink" title="CSS进阶：自动处理CSS3属性前缀"></a>CSS进阶：自动处理CSS3属性前缀</h3><p>通过 postcss-loader 给css3 属性自动添加前缀-webkit,-ms,-o,-moz。</p><p>需要安装两个包postcss-loader 和autoprefixer（自动添加前缀的插件）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev postcss-loader autoprefixer</span><br></pre></td></tr></table></figure></p><p>postcss.config.js【postCSS推荐在项目根目录（和webpack.config.js同级），建立一个postcss.config.js文件。】<br>postcss.config.js配置如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这就是对postCSS一个简单的配置，引入了autoprefixer插件。</span></span><br><span class="line"><span class="comment">//让postCSS拥有添加前缀的能力，它会根据 can i use 来增加相应的css3属性前缀。</span></span><br></pre></td></tr></table></figure></p><p>编写loader配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">"style-loader"</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">"css-loader"</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">           modules: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: <span class="string">"postcss-loader"</span></span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提取CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">配置提取CSS的loader 配置</span><br><span class="line">// 这个配置只能提取到 css文件里需要加前缀的属性，要是需要提取sass或着less ,再另行配置</span><br><span class="line">```js</span><br><span class="line">&#123;</span><br><span class="line">  test: /\.css$/,</span><br><span class="line">  use: extractTextPlugin.extract(&#123;</span><br><span class="line">    fallback: &apos;style-loader&apos;,</span><br><span class="line">    use: [</span><br><span class="line">        &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;,</span><br><span class="line">        &apos;postcss-loader&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结:postcss还有很多功能：<a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener">https://github.com/postcss/postcss-loader</a></p><h3 id="消除未使用的-css"><a href="#消除未使用的-css" class="headerlink" title="消除未使用的 css"></a>消除未使用的 css</h3><p>工作中记得一定要配置这个plugins，因为这决定代码的质量，非常有用。</p><p>像bootstrap这种框架，项目完成后会有很多未使用的css 代码，下面用webpack 去消除。<br>安装PurifyCSS-webpack 【插件】<br>这是一个插件，而不是loader。所以这个需要安装还需要引入。<br>PurifyCSS-webpack要依赖于purify-css这个包，所以这两个都需要安装。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -D是–save-dev ,只是一个简写。</span></span><br><span class="line">cnpm i -D purifycss-webpack purify-css</span><br></pre></td></tr></table></figure></p><p>因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。在webpack.config.js文件头部引入glob。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br></pre></td></tr></table></figure></p><p>同样在webpack.config.js文件头部引入purifycss-webpack<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PurifyCSSPlugin = <span class="built_in">require</span>(<span class="string">"purifycss-webpack"</span>);</span><br></pre></td></tr></table></figure></p><p>配置plugins<br>引入完成后我们需要在webpack.config.js里配置plugins。代码如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    <span class="comment">//new uglify()</span></span><br><span class="line">    <span class="keyword">new</span> htmlPlugin(&#123;</span><br><span class="line">        minify:&#123;</span><br><span class="line">            removeAttrubuteQuotes:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        hash:<span class="literal">true</span>,</span><br><span class="line">        template:<span class="string">'./src/index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> extractTextPlugin(<span class="string">"css/index.css"</span>),</span><br><span class="line">    <span class="keyword">new</span> PurifyCSSPlugin(&#123;</span><br><span class="line">        <span class="comment">// 这里配置了一个paths，主要是需找html模板</span></span><br><span class="line">                <span class="comment">// purifycss根据这个配置会遍历你的文件，查找哪些css被使用了。</span></span><br><span class="line">        paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">        &#125;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置完成后在 css 文件里写入没用的css 重新打包，测试成。</span></span><br><span class="line"><span class="comment">//注意：使用这个插件必须配合extract-text-webpack-plugin这个插件【上面第九节有次插件记录】.</span></span><br></pre></td></tr></table></figure></p><h3 id="Babel转换-ES6"><a href="#Babel转换-ES6" class="headerlink" title="Babel转换 ES6"></a>Babel转换 ES6</h3><p>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。<br>首先一次性安装这些依赖包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</span><br></pre></td></tr></table></figure></p><p>在webpack中配置Babel的方法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test:<span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">  use:&#123;</span><br><span class="line">      loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">      options:&#123;</span><br><span class="line">          presets:[</span><br><span class="line">              <span class="string">"es2015"</span>,<span class="string">"react"</span></span><br><span class="line">          ]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在你已经可以用webapck转换ES6的语法兼容各个浏览器了，可以试着修改一下entry.js的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> css <span class="keyword">from</span> <span class="string">'./css/index.css'</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> jspangString = <span class="string">'Hello Webpack'</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'title'</span>).innerHTML=jspangString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置完毕，重新打包，es6转换成功</span></span><br></pre></td></tr></table></figure></p><p>.babelrc配置<br>虽然Babel可以直接在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，如果卸载webapck.config.js中会非常的雍长不可阅读，所以我们经常把配置卸载.babelrc文件里。<br>在项目根目录新建.babelrc文件，并把配置写到文件里。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc文件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"react"</span>,<span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br><span class="line">webpack.config.js里的loader配置</span><br><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ENV：<br>现在网络上已经不流行babel-preset-es2015，现在官方推荐使用的是babel-preset-env,记录一下env的配置方法。<br>首先需要下载：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-devv babel-preset-env</span><br></pre></td></tr></table></figure></p><p>然后修改.babelrc里的配置文件。其实只要把之前的es2015换成env就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"react"</span>,<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小结:在实际工作中还是要安装Babel的，这样能更好的兼容每种浏览器，而把Babel的配置文件分解出来是最好的选择。</p><h3 id="打包后如何调试"><a href="#打包后如何调试" class="headerlink" title="打包后如何调试"></a>打包后如何调试</h3><p><a href="http://jspang.com/2017/09/16/webpack3-2/#14csscss" target="_blank" rel="noopener">http://jspang.com/2017/09/16/webpack3-2/#14csscss</a></p><h3 id="实战技巧：开发和生产并行设置"><a href="#实战技巧：开发和生产并行设置" class="headerlink" title="实战技巧：开发和生产并行设置"></a>实战技巧：开发和生产并行设置</h3><p>依赖不同【一个项目中是有开发环境和生产环境的，这两个环境的依赖也是不同的。】<br>开发依赖：<br>只在开发中用来帮助你进行开发，简化代码或者生成兼容设置的依赖包。你可以打开package.json来查看，devDependencies的下面的这些包为开发使用的包。这些包在生产环境中并没有用处。<br>生产依赖：<br>就是比如我们的js使用了jquery，jquery的程序要在浏览器端起作用，也就是说我们最终的程序也需要这个包，这就是生产依赖。这些包在dependencies中。</p><p>npm安装<br>假如我们要在项目中使用jquery库，这时候我们一般有三种安装方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">npm install jquery</span><br><span class="line"><span class="comment">//安装完成后，你会发现在package.json中并不存在这个包的依赖。</span></span><br><span class="line"><span class="comment">//如果你项目拷贝给别人继续开发，或者别人和你git合作，再次下载项目npm install时就会缺少这个jquery包。</span></span><br><span class="line"><span class="comment">//项目就会无法正常运行，所以这也是我们最不赞成的安装方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">npm install jquery --save</span><br><span class="line"><span class="comment">//安装完成后，它存在于package.json的dependencies中，也就是说它是生产环境需要依赖的包（上线时需要的依赖包）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">npm install jquery --save-dev</span><br><span class="line">安装完成后，它存在于package.json的devDependencies中，也就是说它是开发环境中需要的，上线并不需要这个包的依赖。</span><br></pre></td></tr></table></figure></p><p>小节：开发时注意哪些依赖是生产环境需要，避免不必要的错误</p><p>安装全部项目依赖包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>安装生产环境依赖包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --production</span><br></pre></td></tr></table></figure></p><p>配置生产和开发并行<br>之前的配置中设置了一个变量website，用于静态资源正确找到路径。那如果生产环境和开发环境不一样，而且我们需要来回切换，这时候我们需要更好的设置方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> website=&#123;</span><br><span class="line">    publicPath:<span class="string">"http://192.168.0.104:1717/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改package.json命令<br>其实就是添加一个dev设置，并通过环境变量来进行区分，下面是package.json里的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"server"</span>: <span class="string">"webpack-dev-server --open"</span>,</span><br><span class="line">   <span class="string">"dev"</span>:<span class="string">"set type=dev&amp;webapck"</span>,</span><br><span class="line">   <span class="string">"build"</span>: <span class="string">"set type=build&amp;webpack"</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>修改webpack.config.js文件<br>可以利用node的语法来读取type的值，然后根据type的值用if–else判断。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.env.type== <span class="string">"build"</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> website=&#123;</span><br><span class="line">        publicPath:<span class="string">"http://192.168.0.104:1717/"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> website=&#123;</span><br><span class="line">        publicPath:<span class="string">"http://cdn.jspang.com/"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想看一下传过来的值到底是什么？可以用下面的输出语句。</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">encodeURIComponent</span>(process.env.type) );</span><br></pre></td></tr></table></figure></p><p>Mac下的package.json设置<br>MAC电脑下需要把set换成export，并且要多加一个&amp;符，具体代码如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"webpack-dev-server --open"</span>,</span><br><span class="line">    <span class="string">"dev"</span>:<span class="string">"export type=dev&amp;&amp;webpack"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"export type=build&amp;&amp;webpack"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="实战技巧：webpack模块化配置【用于大型项目】"><a href="#实战技巧：webpack模块化配置【用于大型项目】" class="headerlink" title="实战技巧：webpack模块化配置【用于大型项目】"></a>实战技巧：webpack模块化配置【用于大型项目】</h3><p>回顾es6 中模块化代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//common.js 导出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jspang</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'jspang.com:'</span>+<span class="string">'webpack'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports=jspang;</span><br><span class="line"></span><br><span class="line"><span class="comment">//other.js 引入</span></span><br><span class="line"><span class="keyword">import</span> jspang <span class="keyword">from</span> <span class="string">'./jspang.js'</span>;</span><br><span class="line">jspang();</span><br></pre></td></tr></table></figure></p><p>webpack模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先在根目录，新建一个webpack_config文件夹，然后新建entry_webpack.js文件，代码如下：</span></span><br><span class="line"><span class="comment">//声明entry变量</span></span><br><span class="line"><span class="keyword">const</span> entry =&#123;&#125;;  </span><br><span class="line"><span class="comment">//声明路径属性</span></span><br><span class="line">entry.path=&#123;</span><br><span class="line">    entry:<span class="string">'./src/entry.js'</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行模块化</span></span><br><span class="line"><span class="built_in">module</span>.exports =entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置的模块化代码编写好以后，需要在webpack.config.js中引入，注意这里的引入只能使用require的方法。</span></span><br><span class="line"><span class="keyword">const</span> entry = <span class="built_in">require</span>(<span class="string">"./webpack_config/entry_webpack.js"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在入口文件部分，修改成如下代码：</span></span><br><span class="line">entry:entry.path,</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时候你可以再次使用npm run dev 进行测试，会发现模块化成功了。</span></span><br></pre></td></tr></table></figure></p><h3 id="优雅打包第三方类库"><a href="#优雅打包第三方类库" class="headerlink" title="优雅打包第三方类库"></a>优雅打包第三方类库</h3><p>第一种(比较常用)：引用 jquery<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产环境 --save</span></span><br><span class="line">npm install --save jquery</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改entry.js文件</span></span><br><span class="line"><span class="comment">//需要引入到entry.js中，这里直接使用import进行引入就可以。</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入jquery测试代码， npm run server进行测试</span></span><br><span class="line"><span class="comment">//需要说的是不仅可以在入口中进行引入，还可以在任何需要的js中引入。</span></span><br><span class="line"><span class="comment">//webpack并不会重复打包，它只给我们打包一次。</span></span><br></pre></td></tr></table></figure></p><p>用plugin引入<br>在webapck.config.js中配置的方法，这种不需要你在入口文件中引入，而是webpack给你作了全局引入。这个插件就是ProvidePlugin。<br>ProvidePlugin是一个webpack自带的插件，Provide的意思就是装备、提供。因为ProvidePlugin是webpack自带的插件，所以要先再webpack.config.js中引入webpack。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入成功后配置我们的plugins模块，代码如下。</span></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">        $:<span class="string">"jquery"</span></span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><p>配置好后，就可以在你的入口文件中使用了，而不用再次引入了。这是一种全局的引入，在实际工作中也可以很好的规范项目所使用的第三方库。</p><h3 id="实战技巧：watch的正确使用方法"><a href="#实战技巧：watch的正确使用方法" class="headerlink" title="实战技巧：watch的正确使用方法"></a>实战技巧：watch的正确使用方法</h3><p>每次手动打包显然比较麻烦，使用 webpack –watch 进行实时打包</p><p>watch的配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchOptions:&#123;</span><br><span class="line">    <span class="comment">//检测修改的时间，以毫秒为单位</span></span><br><span class="line">    poll:<span class="number">1000</span>,</span><br><span class="line">    <span class="comment">//防止重复保存而发生重复编译错误。这里设置的500是半秒内重复保存，不进行打包操作</span></span><br><span class="line">    aggregeateTimeout:<span class="number">500</span>,</span><br><span class="line">    <span class="comment">//不监听的目录</span></span><br><span class="line">    ignored:<span class="regexp">/node_modules/</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BannerPlugin插件(小技巧)<br>使用后会在JS中加上我们的版权或开发者声明(适用于团队开发区分作者)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js /plugins 下加入以下配置</span></span><br><span class="line"><span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'JSPang版权所有，看官方免费视频到jspang.com收看'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要注意的是在使用这个插件之前必须引入webpack。</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="实战技巧：webpack优化黑技能"><a href="#实战技巧：webpack优化黑技能" class="headerlink" title="实战技巧：webpack优化黑技能"></a>实战技巧：webpack优化黑技能</h3><p>ProvidePlugin 和 import<br>比如 19节引入的jquery, 两种引入方法的区别</p><blockquote><p>import引入方法：<br>引用后不管你在代码中使用不适用该类库，都会把该类库打包起来，这样有时就会让代码产生冗余。<br>ProvidePlugin引入方法：<br>引用后只有在类库使用时，才按需进行打包，所以建议在工作使用插件的方式进行引入。</p></blockquote><p>抽离JQuery<br>往往把第三方类库抽离出来，才是最好的解决方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：修改入口文件</span></span><br><span class="line"><span class="comment">// 抽离的第一步是修改入口文件，把我们的JQuery也加入到入口文件中，看下面的代码。</span></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"> entry:&#123;</span><br><span class="line">        entry:<span class="string">'./src/entry.js'</span>,</span><br><span class="line">        jquery:<span class="string">'jquery'</span></span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步: 引入插件【需要引入optimize优化插件，插件里边是需要配置的，如下。】</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">        <span class="comment">//name对应入口文件中的名字，我们起的是jquery</span></span><br><span class="line">            <span class="comment">//【filename是可以省略的，这是直接打包到了打包根目录下，我们这里直接打包到了dist文件夹下边。】</span></span><br><span class="line">    name:<span class="string">'jquery'</span>,</span><br><span class="line">        <span class="comment">//把文件打包到哪里，是一个路径</span></span><br><span class="line">    filename:<span class="string">"assets/js/jquery.min.js"</span>,</span><br><span class="line">        <span class="comment">//最小打包的文件模块数，这里直接写2就好</span></span><br><span class="line">            <span class="comment">//minChunks一般都是固定配置，但是不写是不行的，你会打包失败。</span></span><br><span class="line">    minChunks:<span class="number">2</span></span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置完成，删除dist 文件，webpack再次打包，发现jquery被抽离出来，并且entry.js 文件变得很小。</span></span><br></pre></td></tr></table></figure></p><p>多个第三方类库抽离<br>实际开发会引入多个第三方类库，这时也需要抽离，拿Vue 为例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先安装</span></span><br><span class="line">cnpm install vue --save</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在入口配置 vue 和jquery</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    entry: <span class="string">'./src/entry.js'</span>,</span><br><span class="line">    jquery: <span class="string">'jquery'</span>,</span><br><span class="line">    vue: <span class="string">'vue'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后修改 CommonsChunkPlugin 配置【修改两个位置】</span></span><br><span class="line"><span class="comment">//1.name属性里把原来的字符串改为数组，因为我们要引入多个模块，所以是数组；</span></span><br><span class="line"><span class="comment">//2.filename属性中把我们输出的文件名改为匹配符[name],这项操作就是打包出来的名字跟随我们打包前的模块。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">        <span class="comment">//name对应入口文件中的名字，我们起的是jQuery</span></span><br><span class="line">    name:[<span class="string">'jquery'</span>,<span class="string">'vue'</span>],</span><br><span class="line">        <span class="comment">//把文件打包到哪里，是一个路径</span></span><br><span class="line">    filename:<span class="string">"assets/js/[name].js"</span>,</span><br><span class="line">        <span class="comment">//最小打包的文件模块数，这里直接写2就好</span></span><br><span class="line">    minChunks:<span class="number">2</span></span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置好后，我们就可以在控制台输入webpack进行打包了。你会看到我们预想的结果，jquery和vue都被我们抽离出来了。</span></span><br></pre></td></tr></table></figure></p><p>总结：以后可以用这种方法对第三方类库全部抽离，这样在项目维护和性能上都是不错的选择</p><h3 id="实战技巧：静态资源集中输出"><a href="#实战技巧：静态资源集中输出" class="headerlink" title="实战技巧：静态资源集中输出"></a>实战技巧：静态资源集中输出</h3><p>工作中会有一些已经存在但在项目中没有引用的图片资源或者其他静态资源（比如设计图、开发文档），这些静态资源有可能是文档，也有可能是一些额外的图片。<br>你打包时如果需要保留这些静态资源，直接打包到指定文件夹。其实打包这些资源只需要用到copy-webpack-plugin。</p><p>使用copy-webpack-plugin<br>copy-webpack-plugin就是专门为我们作静态资源转移的插件，它是需要安装的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev copy-webpack-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装好后，需要在webpack.config.js文件的头部引入这个插件才可以使用。</span></span><br><span class="line"><span class="keyword">const</span> copyWebpackPlugin= <span class="built_in">require</span>(<span class="string">"copy-webpack-plugin"</span>);</span><br></pre></td></tr></table></figure></p><p>配置插件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//plugins里边进行配置插件</span></span><br><span class="line"><span class="keyword">new</span> copyWebpackPlugin([&#123;</span><br><span class="line">        <span class="keyword">from</span>:__dirname+<span class="string">'/src/public'</span>,</span><br><span class="line">        to:<span class="string">'./public'</span></span><br><span class="line">    &#125;])</span><br><span class="line"><span class="comment">//from:要打包的静态资源目录地址，这里的__dirname是指项目目录下，是node的一种语法，可以直接定位到本机的项目目录中。</span></span><br><span class="line"><span class="comment">//to:要打包到的文件夹路径，跟随output配置中的目录。所以不需要再自己加__dirname。</span></span><br></pre></td></tr></table></figure></p><p>配置完成webpack 打包，发现静态资源按照我们的配置打包了过去。</p><p>from: <a href="http://jspang.com/2017/09/16/webpack3-2/" target="_blank" rel="noopener">http://jspang.com/2017/09/16/webpack3-2/</a></p>]]></content>
    
    <summary type="html">
    
      关于webpack
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
